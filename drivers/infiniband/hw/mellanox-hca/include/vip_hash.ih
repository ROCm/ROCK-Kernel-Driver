/*
  This software is available to you under a choice of one of two
  licenses.  You may choose to be licensed under the terms of the GNU
  General Public License (GPL) Version 2, available at
  <http://www.fsf.org/copyleft/gpl.html>, or the OpenIB.org BSD
  license, available in the LICENSE.TXT file accompanying this
  software.  These details are also available at
  <http://openib.org/license.html>.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.

  Copyright (c) 2004 Mellanox Technologies Ltd.  All rights reserved.
*/


/*
 *  Description: Common header for vip_hash{,p}.h
 *
 *  For the sake of unifying functionality and implementation,
 *  we use here (and so in vip_hash.ic) magic macros that do
 *  "Manual C++-like template functions".
 *  Thus the function come in (currently two) flavors:
 *     VIP_hash_foo(...)  - where entry's value is  VIP_array_handle_t
 *     VIP_hashp_foo(...) - where entry's value is  void*
 *      
 *  Notes:
 *    This 'inline' header file
 *     + must NOT be included directly by clients.
 *     + is intentionally not guarded with {#ifndef foo, #define foo, #endif},
 *
 *  Version: $Id: vip_hash.ih,v 1.10.2.2 2004/02/25 14:44:29 tziporet Exp $
 *
 *  Authors:
 *    MST - mtsirkin@mellanox.co.il
 *    yotam - yotamm@mellanox.co.il
 *
 *  Changes:
 */           
 

#if !defined(__VIP_HASH_VARIANT)
# error  __VIP_HASH_VARIANT  undefined
#endif

#if !defined(__VIP_hash_key_t_DEFINED)
#define __VIP_hash_key_t_DEFINED

 typedef u_int32_t       VIP_hash_key_t;
 typedef VIP_hash_key_t  VIP_hashp_key_t;
 typedef void*           VIP_hashp2p_key_t;
 typedef u_int64_t       VIP_hash64p_key_t;
 typedef u_int32_t       VIP_hashv4p_key_t[4];

#endif /* __VIP_hash_key_t_DEFINED */


/* Pseudo C++ template for poor C */
# undef __VIP_HASH_KEY_T
# undef __VIP_HASH_VAL_T       
# undef __VIP_HASH_T            
# undef __VIP_HASH_PICK

#if   __VIP_HASH_VARIANT == 0
# define __VIP_HASH_KEY_T        VIP_hash_key_t
# define __VIP_HASH_VAL_T        VIP_hash_value_t
# define __VIP_HASH_T            VIP_hash_p_t
# define __VIP_HASH_PICK(id, idp, idp2p, id64p, idv4p)  id
#elif __VIP_HASH_VARIANT == 1
# define __VIP_HASH_KEY_T        VIP_hash_key_t
# define __VIP_HASH_VAL_T        VIP_hashp_value_t
# define __VIP_HASH_T            VIP_hashp_p_t
# define __VIP_HASH_PICK(id1, idp, idp2p, id64p, idv4p) idp
#elif __VIP_HASH_VARIANT == 2
# define __VIP_HASH_KEY_T        VIP_hashp2p_key_t
# define __VIP_HASH_VAL_T        VIP_hashp2p_value_t
# define __VIP_HASH_T            VIP_hashp2p_p_t
# define __VIP_HASH_PICK(id1, idp, idp2p, id64p, idv4p) idp2p
#elif __VIP_HASH_VARIANT == 3
# define __VIP_HASH_KEY_T        VIP_hash64p_key_t
# define __VIP_HASH_VAL_T        VIP_hash64p_value_t
# define __VIP_HASH_T            VIP_hash64p_p_t
# define __VIP_HASH_PICK(id1, idp, idp2p, id64p, idv4p) id64p
#elif __VIP_HASH_VARIANT == 4
# define __VIP_HASH_KEY_T        VIP_hashv4p_key_t
# define __VIP_HASH_VAL_T        VIP_hashv4p_value_t
# define __VIP_HASH_T            VIP_hashv4p_p_t
# define __VIP_HASH_PICK(id1, idp, idp2p, id64p, idv4p) idv4p
#else
# error Unsupported __VIP_HASH_VARIANT variant
#endif

 /********************************************************************************
 * Function: VIP_hash<v>_create_maxsize
 *
 * Arguments:
 *  reserve (IN) - (Approximate) initial size of the table. 
 *                 Specify 0 for empty initialization that may grow.
 *
 *  max_size(IN) - Approximate Maximum allowed number of buckets in table.  The
 *                 true number will be the next larger prime number in the table of
 *                 primes in file vip_hash.c
 *
 *  VIP_hash<v>_p (OUT) - Return new VIP_hash<v> object here
 *                 Set to NULL in case of an error
 *
 * Returns:
 *  VIP_OK, 
 *  VIP_EAGAIN: Not enough resources
 *
 * Description:
 *   Create a new VIP_hash<v> table.
 *   The table maintans a logical flag controlling whether
 *   its buckets-size may grow. This can be set later with
 *   the VIP_hash<v>_may_grow(flag) function (see later).
 *   This may_grow flag is initialized with TRUE.  When the allocated number of
 *   buckets reaches the maximum value, the may_grow flag is set FALSE.
 *
 *   When may_grow is TRUE, the table will try to set 
 *   the internal buckets size to some prime larger than the 
 *   the content size of the table. The buckets may grows
 *   upon insert. Insertion can succeed even when failing to grow.
 *   In such cases, buckets list will simply get longer.
 *
 ******************************************************************************/
VIP_common_ret_t __VIP_HASH_PICK(VIP_hash_create_maxsize, 
                                 VIP_hashp_create_maxsize, 
                                 VIP_hashp2p_create_maxsize,
                                 VIP_hash64p_create_maxsize,
                                 VIP_hashv4p_create_maxsize)
(u_int32_t reserve, u_int32_t max_size, __VIP_HASH_T* hash_p);


/********************************************************************************
 * Function: VIP_hash<v>_create
 *
 * Arguments:
 *  reserve (IN) - (Approximate) initial size of the table. 
 *                 Specify 0 for empty initialization that may grow.
 *
 *  VIP_hash<v>_p (OUT) - Return new VIP_hash<v> object here
 *                 Set to NULL in case of an error
 *
 * Returns:
 *  VIP_OK, 
 *  VIP_EAGAIN: Not enough resources
 *
 * Description:
 *   Create a new VIP_hash<v> table.
 *   The table maintans a logical flag controlling whether
 *   its buckets-size may grow. This can be set later with
 *   the VIP_hash<v>_may_grow(flag) function (see later).
 *   This may_grow flag is initialized with TRUE.
 *
 *   When may_grow is TRUE, the table will try to set 
 *   the internal buckets size to some prime larger than the 
 *   the content size of the table. The buckets may grows
 *   upon insert. Insertion can succeed even when failing to grow.
 *   In such cases, buckets list will simply get longer.
 *
 ******************************************************************************/
VIP_common_ret_t __VIP_HASH_PICK(VIP_hash_create, 
                                 VIP_hashp_create, 
                                 VIP_hashp2p_create,
                                 VIP_hash64p_create,
                                 VIP_hashv4p_create)
(u_int32_t reserve, __VIP_HASH_T* hash_p);


/********************************************************************************
 * Function: VIP_hash<v>_destroy
 *
 * Arguments:
 *  hash_tbl (IN) - Object to destroy
 *  For the 'hashp' variant:
 *  free_objects_fun (IN) - If non zero, call this function
 *                          for each object in the array (can be used
 *                          e.g. to deallocate memory).
 *                          Even if zero, the table is still deallocated.
 *  priv_data (IN)        - Private date (e.g., object context) common to all objects
 *                          (valid on if free_objects_fun != NULL)
 *
 * Returns:
 *  VIP_OK
 *
 * Description:
 *   cleanup resources for a hash_tbl table
 *
 * NOTE:
 *   given free_objects_fun is invoked in DPC level.
 *   It may not "go to sleep" and may not invoke VIP_hash functions for this table
 *
 ******************************************************************************/
VIP_common_ret_t
#if __VIP_HASH_VARIANT != 1 && __VIP_HASH_VARIANT != 2 && __VIP_HASH_VARIANT != 3 && __VIP_HASH_VARIANT != 4
   __VIP_HASH_PICK(VIP_hash_destroy,
                   VIP_hashp_destroy BUTNOTUSEDHERE,
                   VIP_hashp2p_destroy BUTNOTUSEDHERE,
                   VIP_hash64p_destroy BUTNOTUSEDHERE,
                   VIP_hashv4p_destroy BUTNOTUSEDHERE)
   (__VIP_HASH_T          hash_tbl)
#else /*  __VIP_HASH_VARIANT == 1 */
   __VIP_HASH_PICK(VIP_hash_destroy BUTNOTUSEDHERE,
                   VIP_hashp_destroy,
                   VIP_hashp2p_destroy ,
                   VIP_hash64p_destroy,
                   VIP_hashv4p_destroy) (
   __VIP_HASH_T          hash_tbl,
  void          (*free_objects_fun)(__VIP_HASH_KEY_T key, __VIP_HASH_VAL_T val, void* priv_data),
  void*          priv_data
 )
#endif
;

/********************************************************************************
 * Function: VIP_hash<v>_insert
 *
 * Arguments:
 *  hash_tbl (IN) - Insert in this table
 *  key (IN) - Key to insert
 *  val (IN) - Value to insert
 *
 * Returns:
 *  VIP_OK, 
 *  VIP_EBUSY: the key is already in the hash_tbl
 *  VIP_EAGAIN: not enough resources
 *
 * Description:
 *   Associate this value with this key.
 *
 ********************************************************************************/
VIP_common_ret_t __VIP_HASH_PICK(VIP_hash_insert, 
                                 VIP_hashp_insert,
                                 VIP_hashp2p_insert,
                                 VIP_hash64p_insert,
                                 VIP_hashv4p_insert)(
  __VIP_HASH_T      hash_tbl, 
  __VIP_HASH_KEY_T  key, 
  __VIP_HASH_VAL_T  val);

/********************************************************************************
 * Function: VIP_hash<v>_insert_ptr
 *
 * Arguments:
 *  hash_tbl (IN) - Insert in this table
 *  key (IN) - Key to insert
 *  tval_p (OUT) - Value associated with the key
 *
 * Returns:
 *  VIP_OK, 
 *  VIP_EBUSY: the key is already in the hash_tbl
 *  VIP_EAGAIN: not enough resources
 *
 * Description:
 *   Associate a new value with this key.
 *   This is like VIP_hash<v>_insert, but outputs a pointer
 *   to the value field, through which the value may be set later.
 *
 *   Note: if the key is already in the hash_tbl, 
 *   the returned value in tval_p points to the existing entry
 *
 *****************************************************************************/
VIP_common_ret_t __VIP_HASH_PICK(VIP_hash_insert_ptr, 
                                 VIP_hashp_insert_ptr,
                                 VIP_hashp2p_insert_ptr,
                                 VIP_hash64p_insert_ptr,
                                 VIP_hashv4p_insert_ptr)(
  __VIP_HASH_T        hash_tbl, 
  __VIP_HASH_KEY_T    key,
  __VIP_HASH_VAL_T**  tval_p);

/******************************************************************************
 * Function: VIP_hash<v>_erase
 *
 * Arguments:
 *  hash_tbl (IN) - Erase in this table
 *  key (IN) - remove value by this key
 *  val (OUT) - if non zero, returns the value by this key here
 *
 * Returns:
 *  VIP_OK, 
 *  VIP_EINVAL_HNDL: key is not in the hash_tbl
 *
 * Description:
 *   Remove the value associated with this key
 *   Note: fails if key is not already in the hash_tbl
 *
 ******************************************************************************/
VIP_common_ret_t __VIP_HASH_PICK(VIP_hash_erase, 
                                 VIP_hashp_erase,
                                 VIP_hashp2p_erase,
                                 VIP_hash64p_erase,
                                 VIP_hashv4p_erase)(
  __VIP_HASH_T       hash_tbl,
  __VIP_HASH_KEY_T   key,
  __VIP_HASH_VAL_T*  val);

/******************************************************************************
 * Function: VIP_hash<v>_find
 *
 * Arguments:
 *  hash_tbl (IN) - Insert in this table
 *  key (IN) - remove value by this key
 *  val (OUT) - if non zero, returns the value by this key here
 *
 * Returns:
 *  VIP_OK, 
 *  VIP_EINVAL_HNDL: key is not in the hash_tbl
 *
 * Description:
 *   Find the value associated with this key
 *   Note: fails if key is not already in the hash_tbl
 *
 ******************************************************************************/
VIP_common_ret_t __VIP_HASH_PICK(VIP_hash_find, 
                                 VIP_hashp_find,
                                 VIP_hashp2p_find,
                                 VIP_hash64p_find,
                                 VIP_hashv4p_find)(
  __VIP_HASH_T       hash_tbl,
  __VIP_HASH_KEY_T   key,
  __VIP_HASH_VAL_T*  val);

/******************************************************************************
 * Function: VIP_hash<v>_find_ptr
 *
 * Arguments:
 *  hash_tbl (IN) - Find in this table
 *  key (IN) - remove value by this key
 *  val_p (OUT) - if non zero, contains the pointer to the entry
 *                 coresponding to given key
 *
 * Returns:
 *  VIP_OK, 
 *  VIP_EINVAL_HNDL: key is not in the hash_tbl
 *
 * Description:
 *   Find the value associated with this key
 *   This is like hashp_find, but returns pointer to the
 *   value field, which makes it possible to modify
 *   the value stored by this key.
 *
 *   Note: fails if key is not already in the hash_tbl
 *
 ******************************************************************************/
VIP_common_ret_t __VIP_HASH_PICK(VIP_hash_find_ptr, 
                                 VIP_hashp_find_ptr,
                                 VIP_hashp2p_find_ptr,
                                 VIP_hash64p_find_ptr,
                                 VIP_hashv4p_find_ptr)(
  __VIP_HASH_T        hash_tbl,
  __VIP_HASH_KEY_T    key,
  __VIP_HASH_VAL_T**  val_p );

/********************************************************************************
 * Function: VIP_hash[p]_get_num_of_buckets
 *
 * Arguments:
 *  hash_tbl (IN) - table
 *
 * Returns:
 *  number of buckets in the array
 *
 * Description:
 *   Get number of buckets
 *
 ********************************************************************************/
u_int32_t
__VIP_HASH_PICK(VIP_hash_get_num_of_buckets, 
                VIP_hashp_get_num_of_buckets,
                VIP_hashp2p_get_num_of_buckets,
                VIP_hash64p_get_num_of_buckets,
                VIP_hashv4p_get_num_of_buckets)(
  __VIP_HASH_T hash_tbl);

/*******************************************************************************
 * Function: VIP_hash<v>_get_num_of_objects
 *
 * Arguments:
 *  hash_tbl (IN) - table
 *
 * Returns:
 *  number of objects in the array
 *
 * Description:
 *   Get number of objects
 *
 ******************************************************************************/
u_int32_t
__VIP_HASH_PICK(VIP_hash_get_num_of_objects, 
                VIP_hashp_get_num_of_objects,
                VIP_hashp2p_get_num_of_objects,
                VIP_hash64p_get_num_of_objects,
                VIP_hashv4p_get_num_of_objects)(
  __VIP_HASH_T hash_tbl);

/*******************************************************************************
 * Function: VIP_hash<v>_may_grow
 *
 * Arguments:
 *   hash_tbl (IN) - The table handler.
 *   flag (IN) -      Boolean value determining, whether the buckets table
 *                    can grow in size. See VIP_hash<v>_create(...)
 * Returns:
 *   Current (old) setting.
 *
 * Description:
 *   Set the 'may_grow' flag to allow resizing of the buckets 
 *   to some prime larger than the logical size upon insertion.
 *   Note, if the buckets are (still since initialized) are empty,
 *   this may_grow flag will remain TRUE, and the call will be ignored.
 */

MT_bool __VIP_HASH_PICK(VIP_hash_may_grow, 
                        VIP_hashp_may_grow,
                        VIP_hashp2p_may_grow,
                        VIP_hash64p_may_grow,
                        VIP_hashv4p_may_grow)(
  __VIP_HASH_T hash_tbl, 
  MT_bool      flag);



/*******************************************************************************
 * Function: VIP_hash<v>_traverse
 *
 * Arguments:
 *  hash_tbl (IN) - table
 *  ufunc (IN)     - function of given  prototype.
 *                   Traverse will continue as long as ufunc(...)
 *                   returns non zero.
 *  udata (IN      - client data pointer, to be passed to ufunc.
 *
 * Returns:
 *  None
 *
 * Description:
 *   Traverse the buckets, and call ufunc with all entries.
 *   Stops at end, or when user function returns 0.
 *   Could be significantly imporved, if we would keep
 *   a linked list of actually used buckets.
 *
 * Note:
 *   Given ufunc is invoked in DPC level.
 *   The given ufunc may NOT invoke any of VIP_hash functions (for this hash table).
 *   (it WILL cause a deadlock !)
 *
 ******************************************************************************/
void __VIP_HASH_PICK(VIP_hash_traverse, 
                     VIP_hashp_traverse,
                     VIP_hashp2p_traverse,
                     VIP_hash64p_traverse,
                     VIP_hashv4p_traverse)(
  __VIP_HASH_T   hash_tbl,
  int            (*ufunc)(__VIP_HASH_KEY_T key, __VIP_HASH_VAL_T val, void* vp),
  void*          udata
);


