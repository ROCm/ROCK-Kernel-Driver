#  This software is available to you under a choice of one of two
#  licenses.  You may choose to be licensed under the terms of the GNU
#  General Public License (GPL) Version 2, available at
#  <http://www.fsf.org/copyleft/gpl.html>, or the OpenIB.org BSD
#  license, available in the LICENSE.TXT file accompanying this
#  software.  These details are also available at
#  <http://openib.org/license.html>.
#
#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
#  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
#  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
#  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
#  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
#  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
#  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
#  SOFTWARE.
#
#  Copyright (c) 2004 Topspin Communications.  All rights reserved.
#
#  $Id: generate_pkt_access.pl 32 2004-04-09 03:57:42Z roland $

use strict;

die "Must have output type parameter" if (@ARGV < 1);

my $output_type = shift;

#
# Standard perl idiom for numerical sort
#
sub numerically { $a <=> $b; }

sub minpow2 {
  my $n = shift;
  my $r = 8;

  while ($r < $n) {
    $r *= 2;
  }

  return $r;
}

my @output_types = ("type", "header", "access", "conv", "print", "export");

my $access_param = 'uint8_t *pkt_data';
my $print_param  = "tTS_PRINTER printer";  # Parameter to all print functions
my $mgt_class    = "unknown";   # Prefix for names (eg: smp or pma)

sub var_to_type {
  my $typename = shift;

  $typename =~ tr/[a-z]/[A-Z]/;
  $typename;
}

sub var_to_func {
  my $funcname = shift;

  $funcname =~ s/ (^|_) (\w) /\u$2/xg;
  $funcname;
}

sub v_to_f {
  my $funcname = shift;

  $funcname =~ s/ (_) (\w) /\u$2/xg;
  $funcname;
}

sub ts_func {
  v_to_f(join('_', "ts_ib", ${mgt_class}, @_));
}

sub ts_type {
  join('', "t", var_to_type(join('_', "ts_ib", ${mgt_class}, @_)));
}


#
# Verify that the specified output type is known.
#
HEADER_SWITCH: {
  my $otype;

  foreach $otype (@output_types) {
    last HEADER_SWITCH if ($output_type eq $otype);
  }
  die "Output type is not one of \"@output_types\".";
}

print "/*\n";
print " * This file is automatically generated by $0\n";
print " * Edits WILL be lost.\n";
print " */\n";

sub class_start
{
  my ($data_offset) = @_;
  my $payload_offset = $data_offset - 24;   #Mad payload starts 24 bytes in.

  my $class_type = var_to_type($mgt_class);
  my $access_header = "${mgt_class}_access.h";
  my $type_header = "${mgt_class}_types.h";

  if ($output_type eq "header") {
    print <<"HEADER_TOP";

#ifndef _TS_${class_type}_ACCESS_H
#define _TS_${class_type}_ACCESS_H

#include "$type_header"
#include "ts_ib_mad_types.h"
#ifndef W2K_OS
#ifdef __KERNEL__
#include <linux/types.h>
#endif
#endif

#ifndef _TS_PRINTER_DEFINED_
#define _TS_PRINTER_DEFINED_
typedef struct tTS_PRINTER_STRUCT tTS_PRINTER_STRUCT, *tTS_PRINTER;

typedef int (* tTS_PRINTER_FUNCTION)(void *arg, const char *format, ...);

struct tTS_PRINTER_STRUCT {
  tTS_PRINTER_FUNCTION    func;
  void                   *arg;
};
#endif // _TS_PRINTER_DEFINED

#define TS_IB_MAD_TO_${class_type}_DATA(mad) (&(mad)->payload[$payload_offset])

HEADER_TOP

  } elsif ($output_type eq "type") {
    print <<"TYPE_TOP";

#ifndef _TS_${class_type}_TYPES_H
#define _TS_${class_type}_TYPES_H

#include "ts_ib_core_types.h"
#ifndef W2K_OS
#ifdef __KERNEL__
#include <linux/types.h>
#endif
#endif

TYPE_TOP

  } elsif ($output_type eq "access") {
    print <<"ACCESS_TOP";

#include "$access_header"
#include "$type_header"

#ifdef __KERNEL__
#ifndef W2K_OS
#include <asm/byteorder.h>
#endif
#else
#include <netinet/in.h>
#define be16_to_cpu(val) ntohs(val)
#define cpu_to_be16(val) htons(val)
#define be32_to_cpu(val) ntohl(val)
#define cpu_to_be32(val) htonl(val)
#endif /* !__KERNEL__ */


ACCESS_TOP

  } elsif ($output_type eq "conv") {
    print <<"CONV_TOP";

#include "$access_header"
#include "$type_header"
#ifndef W2K_OS
#include <asm/byteorder.h>
#endif

#ifdef __KERNEL__
#include <linux/string.h>
#else
#include <string.h>
#endif /* !__KERNEL__ */

CONV_TOP

  } elsif ($output_type eq "print") {
    print <<"PRINT_TOP";

#include "$access_header"
#include "$type_header"

#include <ts_ib_mad_types.h>
#include <ts_ib_mad_smi_types.h>

#ifdef __KERNEL__
#ifndef W2K_OS
#include <asm/byteorder.h>
#endif
#else
#include <netinet/in.h>
#define be16_to_cpu(val) ntohs(val)
#define cpu_to_be16(val) htons(val)
#define be32_to_cpu(val) ntohl(val)
#define cpu_to_be32(val) htonl(val)
#endif /* !__KERNEL__ */

static void _print_bytes(tTS_PRINTER printer, uint8_t *buf, int len)
{
  while (len--) {
    printer->func(printer->arg, "%02x", *buf++);
  }
}

PRINT_TOP

  } elsif ($output_type eq "export") {
    print <<"EXPORT_TOP";

#include <linux/config.h>
#if defined(CONFIG_MODVERSIONS) && !defined(MODVERSIONS)
#  define MODVERSIONS
#endif

#if defined(MODVERSIONS) && !defined(__GENKSYMS__) && !defined(TS_KERNEL_2_6)
#  include <linux/modversions.h>
#endif

#include <ts_ib_mad_types.h>
#include <ts_ib_mad_smi_types.h>

#include "$access_header"
#include "$type_header"

#define __NO_VERSION__
#include <linux/module.h>

EXPORT_TOP

  }
} # class_start

#
# Data / Functions to deal with the function declarations header file
#
sub header_start {
  print "\n";
}

sub header_element {
  my($packet_var, $elt_name, $elt_size, $num_elt) = @_;
  my $size      = &minpow2($elt_size);
  my $type      = "uint" . "$size" . "_t";
  my $index_param = $num_elt ? ", int which" : "";

  my $func_name = ts_func($packet_var, $elt_name);

  if ($elt_size <= 32) {
    print "$type ${func_name}Get(const $access_param$index_param);\n";
    print "void ${func_name}Set($access_param, ${type} value$index_param);\n";
  } else {
    print "void *${func_name}Get(const $access_param$index_param);\n";
    print "int ${func_name}GetLength(void);\n";
  }
} # header_element

sub header_array_entry {
  my($packet_var, $elt_name) = @_;

  my $func_name = ts_func($packet_var, $elt_name);

  print "void *${func_name}Get(const $access_param, int which);\n";
  print "int ${func_name}GetLength(void);\n";
} # header_array_entry

sub header_end {
  my($packet_var) = @_;

  my $struct_type = ts_type($packet_var);
  my $conv_func = ts_func($packet_var);
  my $cpu_print_name = ts_func($packet_var, "print");
  my $pkt_print_name = ts_func("pkt", $packet_var, "print");

  print "\n";
  print "void ${conv_func}Pack($struct_type $packet_var, $access_param);\n";
  print "void ${conv_func}UnPack($access_param, $struct_type $packet_var);\n";

  print "\n";
  print "void ${cpu_print_name}($print_param, $struct_type $packet_var);\n";
  print "void ${pkt_print_name}($print_param, $access_param);\n";
} # header_end

#
# Data / Functions to deal with the exports file.
#
sub export_start {
  print "\n";
}

sub export_element {
  my($packet_var, $elt_name, $elt_size, $num_elt) = @_;

  my $func_name = ts_func($packet_var, $elt_name);

  print "EXPORT_SYMBOL(${func_name}Get);\n";
  if ($elt_size <= 32) {
    print "EXPORT_SYMBOL(${func_name}Set);\n";
  } else {
    print "EXPORT_SYMBOL(${func_name}GetLength);\n";
  }
} # export_element

sub export_array_entry {
  my($packet_var, $elt_name) = @_;

  my $func_name = ts_func($packet_var, $elt_name);

  print "EXPORT_SYMBOL(${func_name}Get);\n";
  print "EXPORT_SYMBOL(${func_name}GetLength);\n";
} # export_array_entry

sub export_end {
  my($packet_var) = @_;

  my $struct_type = ts_type($packet_var);
  my $conv_func = ts_func($packet_var);
  my $cpu_print_name = ts_func($packet_var, "print");
  my $pkt_print_name = ts_func("pkt", $packet_var, "print");

  print "\n";
  print "EXPORT_SYMBOL(${conv_func}Pack);\n";
  print "EXPORT_SYMBOL(${conv_func}UnPack);\n";

  print "\n";
  print "EXPORT_SYMBOL(${cpu_print_name});\n";
  print "EXPORT_SYMBOL(${pkt_print_name});\n";
} # export_end

#
# Data / Functions to deal with the main structure access C file
#
sub access_element {
  my($packet_var, $elt_var, $elt_size, $elt_off) = @_;
  my $p2_size   = &minpow2($elt_size);
  my $type      = "uint" . "$p2_size" . "_t";
  my $byte      = int($elt_off / 8);

  my $func_name = ts_func($packet_var, $elt_var);

  # We have a odd-sized field.  we'll need to do some shifting and/or masking.
  if ($elt_size < 32 and $elt_size != $p2_size) {
    my $base    = int($elt_off / $p2_size);

    if (int(($elt_size + $elt_off - 1) / $p2_size) != $base) {
      die sprintf("%d-bit type crosses %d-bit boundary", $elt_size, $p2_size);
    }

    my $offset  = $elt_off % $p2_size;
    my $mask = sprintf "0x%02x", (1 << $elt_size) - 1;
    $offset = $p2_size - $offset - $elt_size;
    
    my $conv_in;
    my $conv_out;
    my $access_pkt;

    if ($p2_size == 8) {
      $conv_in     = "";
      $conv_out    = "";
      $access_pkt  = "pkt_data[$base]";
    } elsif ($p2_size == 16) {
      $base       *= 2;
      $conv_in     = "be16_to_cpu";
      $conv_out    = "cpu_to_be16";
      $access_pkt  = "*($type *)&pkt_data[$base]";
    } else {
      $base       *= 4;
      $conv_in     = "be32_to_cpu";
      $conv_out    = "cpu_to_be32";
      $access_pkt  = "*($type *)&pkt_data[$base]";
    }


    if ($offset == 0) {
      print "$type ${func_name}Get(const $access_param) {\n";
      print "  return ${conv_in}(${access_pkt}) & $mask;\n";
      print "}\n\n";

      print "void ${func_name}Set($access_param, ${type} value) {\n";
      print "  $type tmp = $conv_in($access_pkt);\n\n";
      print "  $access_pkt = $conv_out((value & $mask) | (tmp & ~$mask));\n";
      print "}\n\n";
    } else {
      print "$type ${func_name}Get(const $access_param) {\n";
      print "  return ($conv_in($access_pkt) >> $offset) & $mask;\n";
      print "}\n\n";

      print "void ${func_name}Set($access_param, ${type} value) {\n";
      print "  $type tmp = $conv_in($access_pkt);\n\n";
      print "  $access_pkt = $conv_out(((value & $mask) << $offset)\n";
      print "    | (tmp & ~($mask << $offset)));\n";
      print "}\n\n";
    }

    return;
  }

  if ($elt_size == 8) {
    print "$type ${func_name}Get(const $access_param) {\n";
    print "  return pkt_data[$byte];\n";
    print "}\n\n";

    print "void ${func_name}Set($access_param, ${type} value) {\n";
    print "  pkt_data[$byte] = value;\n";
    print "}\n\n";

    return;
  }

  if ($elt_size == 16) {
    die "16 bit quantity at an odd byte offset" if ($byte % 2);

    print "$type ${func_name}Get(const $access_param) {\n";
    print "  return be16_to_cpu(*(($type *) &pkt_data[$byte]));\n";
    print "}\n\n";

    print "void ${func_name}Set($access_param, ${type} value) {\n";
    print "  *(($type *) &pkt_data[$byte]) = cpu_to_be16(value);\n";
    print "}\n\n";

    return;
  }

  if ($elt_size == 32) {
    die "32 bit quantity not at word boundary" if ($byte % 4);

    print "$type ${func_name}Get(const $access_param) {\n";
    print "  return be32_to_cpu(*(($type *) &pkt_data[$byte]));\n";
    print "}\n\n";

    print "void ${func_name}Set($access_param, ${type} value) {\n";
    print "  *(($type *) &pkt_data[$byte]) = cpu_to_be32(value);\n";
    print "}\n\n";

    return;
  }

  if ($elt_size > 32) {
    my $bytes = $elt_size / 8;

    print "void *${func_name}Get(const $access_param) {\n";
    print "  return (void *)&pkt_data[$byte];\n";
    print "}\n\n";

    print "int ${func_name}GetLength(void) {\n";
    print "  return $bytes;\n";
    print "}\n\n";

    return;
  }

  die "unhandled data size $elt_size";
} # access_element

sub access_array_item {
  my($packet_var, $elt_var, $elt_size, $elt_off) = @_;
  my $elt_bytes = int(($elt_size + 7) / 8);
  my $size      = &minpow2($elt_size);
  my $type      = "uint" . "$size" . "_t";
  my $byte      = int($elt_off / 8);
  my $offset    = $elt_off % 8;

  my $func_name = ts_func($packet_var, $elt_var);

  my $index_param = "int which";
  
  my $index     = "$byte + $elt_bytes * which";

  if ($elt_size == 8) {
    print "$type ${func_name}Get(const $access_param, $index_param) {\n";
    print "  return pkt_data[$index];\n";
    print "}\n\n";

    print "void ${func_name}Set($access_param, ${type} value, $index_param) {\n";
    print "  pkt_data[$index] = value;\n";
    print "}\n\n";

    return;
  }

  if ($elt_size == 16) {
    die "16 bit quantity at an odd byte offset" if ($byte % 2);

    print "$type ${func_name}Get(const $access_param, $index_param) {\n";
    print "  return be16_to_cpu(*(($type *) &pkt_data[$index]));\n";
    print "}\n\n";

    print "void ${func_name}Set($access_param, ${type} value, $index_param) {\n";
    print "  *(($type *) &pkt_data[$index]) = cpu_to_be16(value);\n";
    print "}\n\n";

    return;
  }

  if ($elt_size == 32) {
    die "32 bit quantity not at word boundary" if ($byte % 4);

    print "$type ${func_name}Get(const $access_param, $index_param) {\n";
    print "  return be32_to_cpu(*(($type *) &pkt_data[$index]));\n";
    print "}\n\n";

    print "void ${func_name}Set($access_param, ${type} value, $index_param) {\n";
    print "  *(($type *) &pkt_data[$index]) = cpu_to_be32(value);\n";
    print "}\n\n";

    return;
  }

  if ($elt_size > 32) {
    print "void *${func_name}Get(const $access_param, $index_param) {\n";
    print "  return (void *)&pkt_data[$index];\n";
    print "}\n\n";

    print "int ${func_name}GetLength(void) {\n";
    print "  return $elt_bytes;\n";
    print "}\n\n";

    return;
  }

  die "unhandled data size $elt_size in array element";
} # access_array_item

sub access_array_entry {
  my($packet_var, $elt_var, $elt_size, $elt_off) = @_;
  my $elt_bytes   = int(($elt_size + 7) / 8);
  my $byte      = int($elt_off / 8);

  my $func_name   = ts_func($packet_var, $elt_var);

  my $index_param = "int which";
  
  my $index       = "$byte + $elt_bytes * which";

  print "void *${func_name}Get(const $access_param, $index_param) {\n";
  print "  return (void *)&pkt_data[$index];\n";
  print "}\n\n";

  print "int ${func_name}GetLength(void) {\n";
  print "  return $elt_bytes;\n";
  print "}\n\n";
} # access_array_entry

#
# Data / Functions to deal with the type declarations file
#
sub type_start {
  my($packet_type) = @_;

  print "\n";
  printf("typedef struct %s %s,\n", ts_type($packet_type, "STRUCT"),
         ts_type($packet_type, "STRUCT"));
  printf("  *%s;\n\n", ts_type($packet_type));
  printf("struct %s {\n", ts_type($packet_type, "STRUCT"));
}

sub type_element {
  my($elt_name, $ts_type, $elt_size, $num_elt) = @_;
  my $elt_type;
  my $array_size = 0;

  if (not $ts_type eq "no") {
    $elt_type = $ts_type;
  } elsif ($elt_size <= 32) {
    $elt_type = "uint" . minpow2($elt_size) . "_t";
  } else {
    $elt_type = "uint8_t";
    $array_size = $elt_size / 8;
  }

  printf("  %-15s %s", $elt_type, $elt_name);
  printf("[%d]", $num_elt) if ($num_elt);
  printf("[%d]", $array_size) if ($array_size);
  print ";\n";
}

sub type_array_entry {
  my ($entry_var, $elt_var, $num_elt) = @_;
  my $entry_type = ts_type($entry_var, "STRUCT");

  printf("  %-15s %s[%d];\n", $entry_type, $elt_var, $num_elt);
}

sub type_end {
  print "};\n";
}

#
# Data / Functions to deal with the converter file
#
my $conv_pack_func;
my $conv_unpack_func;

sub conv_start {
  my($packet_var, $packet_type,) = @_;

  my $func_name  = ts_func($packet_var);
  my $pkt_param  = ts_type($packet_type) . " $packet_var";

  $conv_pack_func    =
    "\n" .
    "void ${func_name}Pack($pkt_param, $access_param)\n" .
    "{\n";

  $conv_unpack_func  =
    "\n" .
    "void ${func_name}UnPack($access_param, $pkt_param)\n" .
    "{\n";
} # conv_start

sub conv_element {
  my($packet_var, $elt_var, $elt_size, $conv) = @_;
  my $elt_type;
  my $array_size = 0;
  
  my $func_name = ts_func($packet_var, $elt_var);

  my $elt_access = "$packet_var->$elt_var";
  my $pow2_size  = minpow2($elt_size);

  if ($pow2_size == 8 or $conv eq "conv") {
    die "No support for > 32-bit conversion" if ($pow2_size  >= 64);

    $conv_pack_func   .= sprintf("  %sSet(pkt_data, %s);\n",
                          $func_name, $elt_access);
    $conv_unpack_func .= sprintf("  %s = %sGet(pkt_data);\n",
                          $elt_access, $func_name);
    return;
  }

  # We know we're copying
  die "Currently, don't support copying for < 64-bit data" if ($pow2_size < 64);
  $array_size = int($elt_size / 8);
  $conv_pack_func   .= sprintf("  memcpy(%s(pkt_data), %s, %s());\n",
                               "${func_name}Get", $elt_access,
                               "${func_name}GetLength");
  $conv_unpack_func .= sprintf("  memcpy(%s, %s(pkt_data), %s());\n",
                               $elt_access, "${func_name}Get",
                               "${func_name}GetLength");
} # conv_element

sub conv_array_item {
  my($packet_var, $elt_var, $elt_size, $num_elt, $conv) = @_;
  my $elt_type;
  my $array_size = 0;
  
  my $func_name = ts_func($packet_var, $elt_var);

  my $elt_access = "$packet_var->$elt_var\[count\]";
  my $pow2_size  = minpow2($elt_size);

  $conv_pack_func   .=
      "  {\n" .
      "    int count;\n\n" .
      "    for (count = 0; count < $num_elt; count++) {\n";
  $conv_unpack_func .=
      "  {\n" .
      "    int count;\n\n" .
      "    for (count = 0; count < $num_elt; count++) {\n";

  if ($pow2_size == 8 or $conv eq "conv") {
    die "No support for > 32-bit conversion" if ($pow2_size  >= 64);

    $conv_pack_func   .= sprintf("      %sSet(pkt_data, %s, count);\n",
                          $func_name, $elt_access);
    $conv_unpack_func .= sprintf("      %s = %sGet(pkt_data, count);\n",
                          $elt_access, $func_name);
  } else {
    # We know we're copying
    if ($pow2_size < 64) {
      die "Currently, don't support copying for < 64-bit data"
    }
    $array_size = int($elt_size / 8);
    $conv_pack_func   .= sprintf("      memcpy(%s(pkt_data, count), %s, %s());\n",
                                 "${func_name}Get", $elt_access,
                                 "${func_name}GetLength");
    $conv_unpack_func .= sprintf("      memcpy(%s, %s(pkt_data, count), %s());\n",
                                 $elt_access, "${func_name}Get",
                                 "${func_name}GetLength");
  }
  $conv_pack_func   .=
      "    }\n" .
      "  }\n";
  $conv_unpack_func .=
      "    }\n" .
      "  }\n";
} # conv_array_item

sub conv_array_entry {
  my($packet_var, $entry_var, $elt_var, $num_elt) = @_;
  
  my $elt_func   = ts_func($packet_var, $elt_var, "get");
  my $entry_func = ts_func($entry_var);
  my $elt_access = "\&$packet_var->$elt_var\[count\]";

  $conv_pack_func   .=
      "  {\n" .
      "    int count;\n\n" .
      "    for (count = 0; count < $num_elt; count++) {\n" .
      "      ${entry_func}Pack($elt_access, $elt_func(pkt_data, count));\n" .
      "    }\n" .
      "  }\n";

  $conv_unpack_func .=
      "  {\n" .
      "    int count;\n\n" .
      "    for (count = 0; count < $num_elt; count++) {\n" .
      "      ${entry_func}UnPack($elt_func(pkt_data, count), $elt_access);\n" .
      "    }\n" .
      "  }\n";
} # conv_array_entry

sub conv_end {
  my ($packet_var) = @_;

  my $func_name  = ts_func($packet_var);

  $conv_pack_func   .= "} /* ${func_name}Pack */\n\n";
  $conv_unpack_func .= "} /* ${func_name}UnPack */\n\n";

  print $conv_pack_func;
  print $conv_unpack_func;
} # conv_end

#
# Data / Functions to deal with the packet printer file
#
my $print_pkt_func;                       # Print the data payload
my $print_cpu_func;                       # Print the CPU-native structure

sub print_packet_start {
  my($packet_var, $packet_type,) = @_;

  my $cpu_print_name = ts_func($packet_var, "print");
  my $pkt_print_name = ts_func("pkt", $packet_var, "print");
  my $cpu_param      = ts_type($packet_type) . " $packet_var";

  $print_pkt_func    = join('',
      "void ${pkt_print_name}($print_param, $access_param)\n",
      "{\n",
      "  tTS_PRINTER_FUNCTION print = printer->func;\n",
      "  void                *arg   = printer->arg;\n\n",
      "  print(arg, \"${packet_type}\\n\");\n");

  $print_cpu_func    = join('',
      "void ${cpu_print_name}($print_param, $cpu_param)\n",
      "{\n",
      "  tTS_PRINTER_FUNCTION print = printer->func;\n",
      "  void                *arg   = printer->arg;\n\n",
      "  print(arg, \"${packet_type}\\n\");\n");
} # print_packet_start

sub print_entry_start {
  my($packet_var, $packet_type,) = @_;

  my $cpu_print_name = ts_func($packet_var, "print");
  my $pkt_print_name = ts_func("pkt", $packet_var, "print");
  my $cpu_param      = ts_type($packet_type) . " $packet_var";

  $print_pkt_func    = join('',
      "void ${pkt_print_name}($print_param, $access_param)\n",
      "{\n",
      "  tTS_PRINTER_FUNCTION print = printer->func;\n",
      "  void                *arg   = printer->arg;\n\n");

  $print_cpu_func    = join('',
      "void ${cpu_print_name}($print_param, $cpu_param)\n",
      "{\n",
      "  tTS_PRINTER_FUNCTION print = printer->func;\n",
      "  void                *arg   = printer->arg;\n\n");
} # print_entry_start

sub print_element {
  my($packet_var, $elt_var, $elt_size, $conv, $print) = @_;
  
  my $elt_func   = var_to_func($elt_var);
  my $func_name  = ts_func($packet_var, $elt_var, "get");
  my $elt_access = "$packet_var->$elt_var";
  my $pow2_size  = minpow2($elt_size);

  if ($conv eq "copy") {
    if ($pow2_size < 64) {
      die "Currently, don't support copying for < 64-bit data";
    }

    my $array_size = int($elt_size / 8);

    if ($print eq "string") {
      # Handle the packet
      $print_pkt_func .=
          sprintf("  print(arg, \"  %-20s = %%s\\n\", %s(pkt_data));\n",
                  $elt_func, "${func_name}");

      # Handle the CPU-native struct
      $print_cpu_func .=
          sprintf("  print(arg, \"  %-20s = %%s\\n\", %s);\n",
                  $elt_func, "\&$elt_access\[0\]");
    } elsif ($print eq "no") {
      # Handle the packet
      $print_pkt_func = join('', $print_pkt_func,
          sprintf("  print(arg, \"  %-20s = \");\n", $elt_func),
          sprintf("    _print_bytes(printer, %s(pkt_data), %d);\n",
                  "${func_name}", $array_size),
          "    print(arg, \"\\n\");\n");

      # Handle the CPU-native struct
      $print_cpu_func = join('', $print_cpu_func,
          sprintf("  print(arg, \"  %-20s = \");\n", $elt_func),
          sprintf("    _print_bytes(printer, %s, %d);\n",
                  "\&$elt_access\[0\]", $array_size),
          "    print(arg, \"\\n\");\n");
    } else {
      die "Unknown print specifier \"$print\"";
    }
    return;
  }

  if ($print ne "no") {
    die "Don't know how to handle \"$print\" print specifier in conv context.";
  }

  if ($pow2_size == 8) {
    $print_pkt_func .= sprintf("  print(arg, \"  %-20s = %%02x\\n\", %s);\n",
                               $elt_func, "${func_name}(pkt_data)");
    $print_cpu_func .= sprintf("  print(arg, \"  %-20s = %%02x\\n\", %s);\n",
                               $elt_func, $elt_access);
  } elsif ($pow2_size == 16) {
    $print_pkt_func .= sprintf("  print(arg, \"  %-20s = %%04x\\n\", %s);\n",
                               $elt_func, "${func_name}(pkt_data)");
    $print_cpu_func .= sprintf("  print(arg, \"  %-20s = %%04x\\n\", %s);\n",
                               $elt_func, $elt_access);
  } elsif ($pow2_size == 32) {
    $print_pkt_func .= sprintf("  print(arg, \"  %-20s = %%08x\\n\", %s);\n",
                               $elt_func, "${func_name}(pkt_data)");
    $print_cpu_func .= sprintf("  print(arg, \"  %-20s = %%08x\\n\", %s);\n",
                               $elt_func, $elt_access);
  } else {
    die "Don't currently support > 32-bit conversion";
  }

} # print_element

sub print_array_item {
  my($packet_var, $elt_var, $elt_size, $num_elt, $conv, $print) = @_;
  
  my $elt_func = var_to_func($elt_var);
  my $func_name  = ts_func($packet_var, $elt_var, "get");
  my $elt_access = "$packet_var->$elt_var\[count\]";
  my $pow2_size  = minpow2($elt_size);

  my $elt_string = "${elt_func}\[%2d\]";

  die "Don't currently support print specifiers for arrays." if ($print ne "no");

  $print_pkt_func .=
      "  {\n" .
      "    int count;\n\n" .
      "    for (count = 0; count < $num_elt; count++) {\n";

  $print_cpu_func .=
      "  {\n" .
      "    int count;\n\n" .
      "    for (count = 0; count < $num_elt; count++) {\n";

  if ($conv eq "copy") {
    if ($pow2_size < 64) {
      die "Currently, don't support copying for < 64-bit data";
    }

    my $array_size = int($elt_size / 8);

    # Handle the packet
    $print_pkt_func = join('', $print_pkt_func,
        sprintf("      print(arg, \"  %-21s = \", count);\n", $elt_string),
        sprintf("        _print_bytes(printer, %s(pkt_data, count), %d);\n",
                "${func_name}", $array_size),
        "        print(arg, \"\\n\");\n");

    # Handle the CPU-native struct
    $print_cpu_func = join('', $print_cpu_func,
        sprintf("      print(arg, \"  %-21s = \", count);\n", $elt_string),
        sprintf("        _print_bytes(printer, %s, %d);\n",
                "\&$elt_access\[0\]", $array_size),
        "        print(arg, \"\\n\");\n");
  } elsif ($pow2_size == 8) {
    $print_pkt_func .=
        sprintf("      print(arg, \"  %-21s = %%02x\\n\", count, %s);\n",
                             $elt_string, "${func_name}(pkt_data, count)");
    $print_cpu_func .=
        sprintf("      print(arg, \"  %-21s = %%02x\\n\", count, %s);\n",
                             $elt_string, $elt_access);
  } elsif ($pow2_size == 16) {
    $print_pkt_func .=
        sprintf("      print(arg, \"  %-21s = %%04x\\n\", count, %s);\n",
                             $elt_string, "${func_name}(pkt_data, count)");
    $print_cpu_func .=
        sprintf("      print(arg, \"  %-21s = %%04x\\n\", count, %s);\n",
                             $elt_string, $elt_access);
  } elsif ($pow2_size == 32) {
    $print_pkt_func .=
        sprintf("      print(arg, \"  %-21s = %%08x\\n\", count, %s);\n",
                             $elt_string, "${func_name}(pkt_data, count)");
    $print_cpu_func .=
        sprintf("      print(arg, \"  %-21s = %%08x\\n\", count, %s);\n",
                             $elt_string, $elt_access);
  } else {
    die "No support for > 32-bit conversion";
  }

  $print_pkt_func .=
      "    }\n" .
      "  }\n";

  $print_cpu_func .=
      "    }\n" .
      "  }\n";

} # print_array_item

sub print_array_entry {
  my($packet_var, $entry_var, $elt_var, $num_elt) = @_;
  
  my $elt_access = "\&$packet_var->$elt_var\[count\]";
  my $elt_func = ts_func($packet_var, $elt_var, "Get");
  my $cpu_print_name = ts_func($entry_var, "print");
  my $pkt_print_name = ts_func("pkt", $entry_var, "print");
  my $elt_string = var_to_func($elt_var) . "\[%2d\]";

  # Handle the packet
  $print_pkt_func .=
      "  {\n" .
      "    int count;\n\n" .
      "    for (count = 0; count < $num_elt; count++) {\n" .
      sprintf("      print(arg, \"  %-21s = \", count);\n", $elt_string) .
      "      ${pkt_print_name}(printer, $elt_func(pkt_data, count));\n" .
      "    }\n" .
      "  }\n";

  # Handle the CPU-native struct
  $print_cpu_func .=
      "  {\n" .
      "    int count;\n\n" .
      "    for (count = 0; count < $num_elt; count++) {\n" .
      sprintf("      print(arg, \"  %-21s = \", count);\n", $elt_string) .
      "      ${cpu_print_name}(printer, $elt_access);\n" .
      "    }\n" .
      "  }\n";

} # print_array_entry

sub print_end {
  my ($packet_var) = @_;
  my $cpu_print_name = ts_func($packet_var, "print");
  my $pkt_print_name = ts_func("pkt", $packet_var, "print");

  $print_pkt_func .= "} /* ${pkt_print_name} */\n\n";
  $print_cpu_func .= "} /* ${cpu_print_name} */\n\n";

  print $print_pkt_func;
  print $print_cpu_func;
} # print_end

#
# Main Loop
#

my $packet_var;
my $packet_type;
my $packet_attrib;
my @packet_fields;

my %known_attributes;

my $in_packet = 0;
my $in_entry  = 0;

while (<>) {
  next if (/^\#/ or /^\s+$/);
  last if (/^\%DONE/);

  chomp;

  my @linelist = split;

  die "must define CLASS first." if ($mgt_class eq "unknown" && ! /^\%CLASS/);
  
  if (/^\%CLASS/) {    # The name of the mgmt class.  (Used as prefix.)
    die "CLASS needs 2 parameters" if (@linelist != 3);
    
    $mgt_class = $linelist[1];
    my $data_offset = $linelist[2];
    class_start($data_offset);
  } elsif (/^\%PACKET/) {    # The beginning of a packet definition
    die "Can't define PACKET inside PACKET definition" if ($in_packet);
    die "Can't define PACKET inside ENTRY definition" if ($in_entry);
    die "PACKET needs 2 parameters" if (@linelist != 3);
    $in_packet = 1;

    $packet_var = $linelist[1];
    $packet_attrib = hex($linelist[2]);

    $known_attributes{$packet_attrib} = $packet_var;

    # Build the alternative forms of packet names here where we can do it once.
    $packet_type = var_to_type($packet_var);
    @packet_fields = ();

    if ($output_type eq "header") {
      header_start($packet_type);
    } elsif ($output_type eq "type") {
      type_start($packet_type);
    } elsif ($output_type eq "conv") {
      conv_start($packet_var, $packet_type);
    } elsif ($output_type eq "print") {
      print_packet_start($packet_var, $packet_type);
    } elsif ($output_type eq "export") {
      export_start($packet_type);
    }
  } elsif (/^\%END_PACKET/) {   # The end of a packet definition
    die "Ending PACKET, but not inside PACKET definition" if (not $in_packet);
    $in_packet = 0;

    if ($output_type eq "header") {
      header_end($packet_var);
    } elsif ($output_type eq "type") {
      type_end($packet_var);
    } elsif ($output_type eq "conv") {
      conv_end($packet_var);
    } elsif ($output_type eq "print") {
      print_end($packet_var);
    } elsif ($output_type eq "export") {
      export_end($packet_var);
    }
    printf ("/* End of defs for %s (0x%x). */\n", $packet_var, $packet_attrib);
  } elsif (/^\%ENTRY/) {    # The beginning of an entry definition
    die "Can't define ENTRY inside PACKET definition" if ($in_packet);
    die "Can't define ENTRY inside ENTRY definition" if ($in_entry);
    die "ENTRY needs 1 parameters" if (@linelist != 2);
    $in_entry = 1;

    $packet_var = $linelist[1];
    $packet_attrib = hex($linelist[2]);

    # Build the alternative forms of packet names here where we can do it once.
    $packet_type = var_to_type($packet_var);
    @packet_fields = ();

    if ($output_type eq "header") {
      header_start($packet_type);
    } elsif ($output_type eq "type") {
      type_start($packet_type);
    } elsif ($output_type eq "conv") {
      conv_start($packet_var, $packet_type);
    } elsif ($output_type eq "print") {
      print_entry_start($packet_var, $packet_type);
    } elsif ($output_type eq "export") {
      export_start($packet_type);
    }
  } elsif (/^\%END_ENTRY/) {   # The end of an entry definition
    die "Ending ENTRY, but not inside ENTRY definition" if (not $in_entry);
    $in_entry = 0;

    if ($output_type eq "header") {
      header_end($packet_var);
    } elsif ($output_type eq "type") {
      type_end($packet_var);
    } elsif ($output_type eq "conv") {
      conv_end($packet_var);
    } elsif ($output_type eq "print") {
      print_end($packet_var);
    } elsif ($output_type eq "export") {
      export_end($packet_var);
    }
    printf ("/* End of defs for %s. */\n", $packet_var, $packet_attrib);
  } elsif (/^\%ARRAY_ITEM/) {   # An array of items definition
    die "Can't define ARRAY_ITEM outside PACKET def" if (not $in_packet);
    die "ARRAY_ITEM needs 7 parameters" if (@linelist != 8);

    shift @linelist;   # Remove keyword
    my($num_elt, $elt_var, $elt_off, $elt_size, $ts_type, $conv, $print) = @linelist;
    my $elt_func  = $elt_var;

    $elt_func =~ s/ (^|_) (\w) /\u$2/xg;
    push(@packet_fields, $elt_var);

    if ($output_type eq "header") {
      header_element($packet_var, $elt_var, $elt_size, $num_elt);
    } elsif ($output_type eq "access") {
      access_array_item($packet_var, $elt_func, $elt_size, $elt_off);
    } elsif ($output_type eq "type") {
      type_element($elt_var, $ts_type, $elt_size, $num_elt);
    } elsif ($output_type eq "conv") {
      conv_array_item($packet_var, $elt_var, $elt_size, $num_elt, $conv);
    } elsif ($output_type eq "print") {
      print_array_item($packet_var, $elt_var,
                       $elt_size, $num_elt, $conv, $print);
    } elsif ($output_type eq "export") {
      export_element($packet_var, $elt_var, $elt_size, $num_elt);
    }
  } elsif (/^\%ARRAY_ENTRY/) {   # An array of sub-packets
    die "Can't define ARRAY_ENTRY outside PACKET def" if (not $in_packet);
    die "ARRAY_ENTRY needs 5 parameters" if (@linelist != 6);

    shift @linelist;   # Remove keyword
    my($num_elt, $entry_var, $elt_var, $elt_off, $elt_size) = @linelist;

    push(@packet_fields, $elt_var);

    if ($output_type eq "header") {
      header_array_entry($packet_var, $elt_var);
    } elsif ($output_type eq "access") {
      access_array_entry($packet_var, $elt_var, $elt_size, $elt_off);
    } elsif ($output_type eq "type") {
      type_array_entry($entry_var, $elt_var, $num_elt);
    } elsif ($output_type eq "conv") {
      conv_array_entry($packet_var, $entry_var, $elt_var, $num_elt);
    } elsif ($output_type eq "print") {
      print_array_entry($packet_var, $entry_var, $elt_var, $num_elt);
    } elsif ($output_type eq "export") {
      export_array_entry($packet_var, $elt_var);
    }

  } elsif (@linelist == 6) {    # An element of a packet.
    die "Can't define element outside PACKET def" if (not ($in_packet or $in_entry));

    my($elt_var, $elt_off, $elt_size, $ts_type, $conv, $print) = @linelist;

    push(@packet_fields, $elt_var);

    if ($output_type eq "header") {
      header_element($packet_var, $elt_var, $elt_size, 0);
    } elsif ($output_type eq "access") {
      access_element($packet_var, $elt_var, $elt_size, $elt_off);
    } elsif ($output_type eq "type") {
      type_element($elt_var, $ts_type, $elt_size, 0);
    } elsif ($output_type eq "conv") {
      conv_element($packet_var, $elt_var, $elt_size, $conv);
    } elsif ($output_type eq "print") {
      print_element($packet_var, $elt_var, $elt_size, $conv, $print);
    } elsif ($output_type eq "export") {
      export_element($packet_var, $elt_var, $elt_size, 0);
    }
  } else {
    die("Unknown line type.");
  }
}

if ($output_type eq "header") {
  my $func_name = ts_func("print_data");
  my $class_type = var_to_type($mgt_class);

  print "\n";
  print "void $func_name(tTS_PRINTER printer, tTS_IB_MAD mad);\n\n";
  print "#endif /* _TS_${class_type}_ACCESS_H */\n";

} elsif ($output_type eq "type") {
  my $class_type = var_to_type($mgt_class);
  my $attrib_num;
  my $need_comma = 0;
  my $strlen = 0;

  print ("\n");
  print ("typedef enum {");

  # Get the length of the longest attribute into $strlen.
  foreach $attrib_num (keys(%known_attributes)) {
    my $curlen = length($known_attributes{$attrib_num});
    $strlen = $curlen if ($curlen > $strlen);
  }
  $strlen += length("TS_IB_${class_type}_ATTRIB_");

  foreach $attrib_num (sort numerically keys(%known_attributes)) {
    my $attrib_name = var_to_type($known_attributes{$attrib_num});
    $attrib_name = "TS_IB_${class_type}_ATTRIB_${attrib_name}";

    print  "," if ($need_comma);
    print  "\n";
    printf("  %-${strlen}s = 0x%04x", $attrib_name, $attrib_num);
    $need_comma = 1;
  }
  print "\n";
  print "} tTS_IB_${class_type}_ATTRIB;\n";

  print "\n#endif /* _TS_${class_type}_TYPES_H */\n";

} elsif ($output_type eq "print") {
  my $attrib_num;
  my $func_name = ts_func("print_data");
  my $mad_offset = "TS_IB_MAD_TO_" . var_to_type($mgt_class) . "_DATA";

  print "\n";
  print "void $func_name(tTS_PRINTER printer, tTS_IB_MAD mad)\n";
  print "{\n";
  print "  uint16_t attribute = be16_to_cpu(mad->attribute_id);\n\n";

  print "  switch (attribute) {\n";
  foreach $attrib_num (sort numerically keys(%known_attributes)) {
    my $attrib_name = $known_attributes{$attrib_num};
    my $pkt_print_name = ts_func("pkt", $attrib_name, "print");

    printf("    case 0x%04x:\n", $attrib_num);
    print  "      $pkt_print_name(printer, $mad_offset(mad));\n";
    print  "      break;\n";
  }
  print "    default:\n";
  print "      printer->func(printer->arg, \"Unknown attribute 0x%04x\\n\", attribute);\n";
  print "      break;\n";
  print "  }\n";
  print "} /* $func_name */\n";
} elsif ($output_type eq "export") {
  my $func_name = ts_func("print_data");

  print "\n";
  print "EXPORT_SYMBOL($func_name);\n";
}
