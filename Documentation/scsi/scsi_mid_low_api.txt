                          Linux Kernel 2.5 series
                 SCSI mid_level - lower_level driver interface
                 =============================================

Introduction
============
This document outlines the interface between the Linux SCSI mid level and
SCSI lower level drivers. Lower level drivers (LLDs) are variously called 
host bus adapter (HBA) drivers, host drivers (HD) or pseudo adapter drivers.
The latter alludes to the fact that a LLD may be a bridge to another IO 
subsystem (e.g. the "usb-storage" driver). There can be many LLDs in a 
running system, but only one per hardware type. Most LLDs can control one
or more SCSI hosts.

For example, the aic7xxx LLD controls Adaptec SCSI parallel interface
(SPI) controllers based on that company's 7xxx chip series. The aic7xxx
LLD can be built into the kernel or loaded as a module. There can only be
one aic7xxx LLD running in a Linux system but it may be controlling many 
HBAs. These HBAs might be either on PCI daughter-boards or built into 
the motherboard (or both). Like most modern HBAs, each aic7xxx host
has its own PCI device address. [The one-to-one correspondence between
a SCSI host and a PCI device is common but not required (e.g. with
ISA or MCA adapters).]

This version of the document roughly matches linux kernel version 2.5.68 .
This document can be found in the Linux kernel source Documentation/scsi
directory and is called scsi_mid_low_api.txt . A more recent copy may
be found at http://www.torque.net/scsi/scsi_mid_low_api.txt.gz .

Documentation
=============
There is a SCSI documentation directory within the kernel source tree.
That directory is typically /usr/src/linux/Documentation/scsi . Most
documents are in plain (i.e. ASCII) text. This file can be found in that
directory, named scsi_mid_low_api.txt . Many LLDs are documented there
(e.g. aic7xxx.txt). The SCSI mid-level is briefly described in scsi.txt
(with a url to a document describing the SCSI subsystem in the lk 2.4
series). Two upper level drivers have documents in that directory:
st.txt (SCSI tape driver) and scsi-generic.txt (for the sg driver).

Some documentation (or urls) for LLDs may be in the C source code or
in the same directory as the C source code. For example to find a url
about the USB mass storage driver see the 
/usr/src/linux/drivers/usb/storage directory.

The Linux kernel source Documentation/DocBook/scsidrivers.tmpl file
refers to this file. With the appropriate DocBook tool-set, this permits
users to generate html, ps and pdf renderings of information within this
file (e.g. the interface functions).

Driver structure
================
Traditionally a LLD for the SCSI subsystem has been at least two files in
the drivers/scsi directory. For example, a driver called "xyz" has a header
file "xyz.h" and a source file "xyz.c". [Actually there is no good reason
why this couldn't all be in one file; the header file is superfluous.] Some
drivers that have been ported to several operating systems have more than
two files. For example the aic7xxx driver has separate files for generic 
and OS-specific code (e.g. FreeBSD and Linux). Such drivers tend to have
their own directory under the drivers/scsi directory.

When a new LLD is being added to Linux, the following files (found in the
drivers/scsi directory) will need some attention: Makefile and Kconfig .
It is probably best to study how existing LLDs are organized.

As the 2.5 series development kernels evolve, changes are being
introduced into this interface. An example of this is driver
initialization code where there are now 2 models available. The older
one, similar to what was found in the lk 2.4 series, is based on hosts
that are detected at HBA driver load time. This will be referred to
the "passive" initialization model. The newer model allows HBAs to be
hotplugged (and unplugged) while the driver is loaded and will be
referred to as the "hotplug" initialization model. The newer model is
preferred as it can handle both traditional SCSI equipment that is
permanently connected as well as modern "SCSI" usb-storage devices
(e.g. digital cameras) that are hotplugged. Both initialization models
are discussed in the following sections.

A LLD interfaces to the SCSI subsystem several ways:
  a) directly invoking functions supplied by the mid level
  b) passing a set of function pointers to a registration function
     supplied by the mid level. The mid level will then invoke these
     functions at some point in the future. The LLD will supply
     implementations of these functions.
  c) direct access to instances of well known data structures maintained
     by the mid level

Those functions in group a) are listed in a section entitled "Mid level
supplied functions" below.

Those functions in group b) are listed in a section entitled "Interface
functions" below. Their function pointers are placed in the members of
"struct SHT", an instance of which is passed to scsi_register() [or
scsi_register_host() in the passive initialization model]. Those interface
functions that are not mandatory and that the LLD does not wish to supply
should have NULL placed in the corresponding member of struct SHT.
[Defining an instance of struct SHT at file scope will cause NULL to be 
placed in function pointer members not explicitly initialized.]

Those instances in group c) are slowly being removed as they tend to be
"racy" especially in a hotplug environment.

All functions defined within a LLD and all data defined at file scope
should be static. For example the slave_alloc() function in a LLD
called "xxx" could be defined as 
"static int xxx_slave_alloc(struct scsi_device * sdev) { /* code */ }"


Hotplug initialization model
============================
In this model a LLD controls when SCSI hosts are introduced and removed
from the SCSI subsystem. Hosts can be introduced as early as driver
initialization and removed as late as driver shutdown. Typically a driver
will respond to a sysfs probe() callback that indicates a HBA has been
detected. After confirming that the new device is one that the LLD wants
to control, the LLD will initialize the HBA and then register a new host
with the SCSI mid level.

Hot unplugging a HBA that controls a disk which is processing SCSI
commands on a mounted file system is an ugly situation. Issues with
this scenario are still being worked through. The primary concern is
the stability of the kernel (specifically the block and SCSI subsystems)
since the effected disk can be "cleaned up" the next time it is seen.
In the sysfs model, a remove() callback indicates a HBA has disappeared.

During LLD initialization the driver should register itself with the
appropriate IO bus on which it expects to find HBA(s) (e.g. the PCI bus).
This can probably be done via sysfs. Any driver parameters (especially
those that are writable after the driver is loaded) could also be
registered with sysfs at this point. The SCSI mid level first becomes
aware of a LLD when that LLD registers its first HBA.

At some later time, the LLD becomes aware of a HBA and what follows
is a typical sequence of calls between the LLD and the mid level.
This example shows the mid level scanning the newly introduced HBA for 3 
scsi devices of which only the first 2 respond:

[HBA PROBE]
LLD                   mid level                    LLD
---                   ---------                    ---
scsi_register()  -->
scsi_add_host()  --------+
                         |
		    slave_alloc()
                    slave_configure() -->  scsi_adjust_queue_depth()
			 |
		    slave_alloc()
                    slave_configure()
			 |
		    slave_alloc()   **
                    slave_destroy() **

If the LLD wants to adjust the default queue settings, it can invoke
scsi_adjust_queue_depth() in its slave_configure() routine.

** For scsi devices that the mid level tries to scan but do not
   respond, a slave_alloc(), slave_destroy() pair is called.

Here is the corresponding sequence when a host (HBA) is being
removed:

[HBA REMOVE]
LLD                      mid level                 LLD
---                      ---------                 ---
scsi_remove_host() ---------+
                            |
                     slave_destroy()
                     slave_destroy()
                        release()     -->     scsi_unregister()

It is practical for a LLD to keep track of struct Scsi_Host instances
(a pointer is returned by scsi_register() ) and struct scsi_device
instances (a pointer is passed as the parameter to slave_alloc() and
slave_configure() ). Both classes of instances are "owned" by the 
mid-level. struct scsi_device instances are freed after slave_destroy().
struct Scsi_Host instances are freed within scsi_unregister().

TODO:
Descriptions, are the following correct?
[DEVICE hotplug]
LLD                   mid level                    LLD
---                   ---------                    ---
scsi_add_device()  ------+
                         |
		    slave_alloc()
                    slave_configure()   [--> scsi_adjust_queue_depth()]

[DEVICE unplug]
LLD                      mid level                 LLD
---                      ---------                 ---
scsi_set_device_offline()
scsi_remove_device() -------+
                            |
                     slave_destroy()



Passive initialization model
============================
LLD initialization (both built-in and module) and shutdown are "wired
up" by passing function pointers to the module_init() and module_exit()
macros respectively. In this model the function identified by "module_init"
must call scsi_register_host() and the function identified by "module_exit"
must call scsi_unregister_host().
Most LLDs inherited from the lk 2.4 series include a file called
"scsi_module.c" [yes the ".c" is a little surprising] in their
source code. For that file to work a declaration like this is needed before
it is included:
    static struct SHT driver_template = DRIVER_TEMPLATE;
    #include "scsi_module.c"

In this case "DRIVER_TEMPLATE" is defined to be a structure initializer
that is placed in the driver header file by convention. It contains
pointers to supported interface functions and other values.

Here is an example of an initialization sequence when two hosts are
detected (so detect() returns 2) and the SCSI bus scan on each host
finds 1 SCSI device (and a second device does not respond).

LLD                      mid level                 LLD
---                      ---------                 ---
scsi_register_host() -------+
                            |
                         detect()  -----------------+
                            |                       |
                            |                scsi_register()
                            |                scsi_register()
                            |
		      slave_alloc()
                      slave_configure()  -->  scsi_adjust_queue_depth()
		      slave_alloc()   **
		      slave_destroy() **
                            |
		      slave_alloc()
                      slave_configure()
		      slave_alloc()   **
		      slave_destroy() **

The mid level invokes scsi_adjust_queue_depth() with tagged queuing off and
"cmd_per_lun" for that host as the queue length. These settings can be
overridden by a slave_configure() supplied by the LLD.

** For scsi devices that the mid level tries to scan but do not
   respond, a slave_alloc(), slave_destroy() pair is called.

Here is a LLD shutdown sequence:

LLD                      mid level                 LLD
---                      ---------                 ---
scsi_unregister_host() -----+
                            |
                     slave_destroy()
                        release()   -->   scsi_unregister()
                            |
                     slave_destroy()
                        release()   -->   scsi_unregister()

slave_destroy() is optional. 

The shortcoming of the "passive initialization model" is that host
registration and de-registration are (typically) tied to LLD initialization
and shutdown. Once the LLD is initialized then a new host that appears
(e.g. via hotplugging) cannot easily be added without a redundant
driver shutdown and re-initialization.


Conventions
===========
First, Linus's thoughts on C coding can be found in the file 
Documentation/CodingStyle . 

Next, there is a movement to "outlaw" typedefs introducing synonyms for 
struct tags. Both can be still found in the SCSI subsystem, for example: 
"typedef struct SHT { ...} Scsi_Host_Template;" in hosts.h . In this
case "struct SHT" is preferred to "Scsi_Host_Template". [The poor naming
example was chosen with malevolent intent.]

Also, C99 enhancements are encouraged to the extent they are supported
by the relevant gcc compilers. So "//" style comments are encouraged
were appropriate as are C99 style structure and array initializers.
Don't go too far, VLAs are not properly supported yet.

Well written, tested and documented code, need not be re-formatted to
comply with the above conventions. For example, the aic7xxx driver
comes to Linux from FreeBSD and Adaptec's own labs. No doubt FreeBSD
and Adaptec have their own coding conventions.


Mid level supplied functions
============================
These functions are supplied by the SCSI mid level for use by LLDs.
The names (i.e. entry points) of these functions are exported (in 
scsi_syms.c) so a LLD that is a module can access them. The kernel will
arrange for the SCSI mid level to be loaded and initialized before any LLD
is initialized. The functions below are listed alphabetically and their
names all start with "scsi_".

Summary:
   scsi_add_device - creates new scsi device (lu) instance
   scsi_add_host - perform sysfs registration and SCSI bus scan.
   scsi_add_timer - (re-)start timer on a SCSI command.
   scsi_adjust_queue_depth - change the queue depth on a SCSI device
   scsi_assign_lock - replace default host_lock with given lock
   scsi_bios_ptable - return copy of block device's partition table
   scsi_block_requests - prevent further commands being queued to given host
   scsi_delete_timer - cancel timer on a SCSI command.
   scsi_partsize - parse partition table into cylinders, heads + sectors
   scsi_register - create and register a scsi host adapter instance.
   scsi_register_host - register a low level host driver
   scsi_remove_device - detach and remove a SCSI device
   scsi_remove_host - detach and remove all SCSI devices owned by host
   scsi_report_bus_reset - report scsi _bus_ reset observed
   scsi_set_device - place device reference in host structure
   scsi_set_device_offline - set device offline then flush its queue
   scsi_to_pci_dma_dir - convert SCSI subsystem direction flag to PCI
   scsi_to_sbus_dma_dir - convert SCSI subsystem direction flag to SBUS
   scsi_track_queue_full - track successive QUEUE_FULL events 
   scsi_unblock_requests - allow further commands to be queued to given host
   scsi_unregister - unregister and free memory used by host instance
   scsi_unregister_host - unregister a low level host adapter driver

Details:

/**
 * scsi_add_device - creates new scsi device (lu) instance
 * @shost:   pointer to scsi host instance
 * @channel: channel number (rarely other than 0)
 * @id:      target id number
 * @lun:     logical unit number
 *
 *      Returns pointer to new struct scsi_device instance or 
 *	ERR_PTR(-ENODEV) (or some other bent pointer) if something is
 *	wrong (e.g. no lu responds at given address)
 *
 *	Notes: This call is usually performed internally during a scsi
 *	bus scan when a HBA is added (i.e. scsi_add_host()). So it
 *	should only be called if the HBA becomes aware of a new scsi
 *	device (lu) after scsi_add_host() has completed. If successful
 *	this call we lead to slave_alloc() and slave_configure() callbacks
 *	into the LLD.
 *
 *	Defined in: drivers/scsi/scsi_scan.c
 **/
struct scsi_device * scsi_add_device(struct Scsi_Host *shost, 
                                     unsigned int channel,
                                     unsigned int id, unsigned int lun)


/**
 * scsi_add_host - perform sysfs registration and SCSI bus scan.
 * @shost:   pointer to scsi host instance
 * @dev:     pointer to struct device host instance
 *
 *      Returns 0 on success, negative errno of failure (e.g. -ENOMEM)
 *
 *	Notes: Only required in "hotplug initialization model" after a
 *	successful call to scsi_register().
 *
 *	Defined in: drivers/scsi/hosts.c
 **/
int scsi_add_host(struct Scsi_Host *shost, struct device * dev)


/**
 * scsi_add_timer - (re-)start timer on a SCSI command.
 * @scmd:    pointer to scsi command instance
 * @timeout: duration of timeout in "jiffies"
 * @complete: pointer to function to call if timeout expires
 *
 *      Returns nothing
 *
 *	Notes: Each scsi command has its own timer, and as it is added
 *	to the queue, we set up the timer. When the command completes, 
 *      we cancel the timer. A LLD can use this function to change
 *	the existing timeout value.
 *
 *	Defined in: drivers/scsi/scsi_error.c
 **/
void scsi_add_timer(Scsi_Cmnd *scmd, int timeout, void (*complete)
                    (Scsi_Cmnd *))


/**
 * scsi_adjust_queue_depth - change the queue depth on a SCSI device
 * @SDpnt:	pointer to SCSI device to change queue depth on
 * @tagged:	0 - no tagged queuing
 *		MSG_SIMPLE_TAG - simple (unordered) tagged queuing
 *		MSG_ORDERED_TAG - ordered tagged queuing
 * @tags	Number of tags allowed if tagged queuing enabled,
 *		or number of commands the LLD can queue up
 *		in non-tagged mode (as per cmd_per_lun).
 *
 *	Returns nothing
 *
 * 	Notes: Can be invoked any time on a SCSI device controlled by this
 *	LLD. [Specifically during and after slave_configure() and prior to
 *	slave_destroy().] Can safely be invoked from interrupt code. Actual
 *	queue depth change may be delayed until the next command is being
 *	processed.
 *
 *	Defined in: drivers/scsi/scsi.c [see source code for more notes]
 *
 **/
void scsi_adjust_queue_depth(struct scsi_device * SDpnt, int tagged, 
			     int num_tags)


/**
 * scsi_assign_lock - replace default host_lock with given lock
 * @shost: a pointer to a scsi host instance
 * @lock: pointer to lock to replace host_lock for this host
 *
 *      Returns nothing
 *
 *      Defined in: drivers/scsi/hosts.h .
 **/
void scsi_assign_lock(struct Scsi_Host *shost, spinlock_t *lock)


/**
 * scsi_bios_ptable - return copy of block device's partition table
 * @dev:	pointer to block device
 *
 *	Returns pointer to partition table, or NULL for failure
 *
 *	Notes: Caller owns memory returned (free with kfree() )
 *
 *	Defined in: drivers/scsi/scsicam.c
 **/
unsigned char *scsi_bios_ptable(struct block_device *dev)


/**
 * scsi_block_requests - prevent further commands being queued to given host
 *
 * @SHpnt: pointer to host to block commands on
 *
 *	Returns nothing
 *
 * 	Notes: There is no timer nor any other means by which the requests
 *	get unblocked other than the LLD calling scsi_unblock_requests().
 *
 *	Defined in: drivers/scsi/scsi_lib.c
**/
void scsi_block_requests(struct Scsi_Host * SHpnt)


/**
 * scsi_delete_timer - cancel timer on a SCSI command.
 * @scmd:    pointer to scsi command instance
 *
 *      Returns 1 if able to cancel timer else 0 (i.e. too late or already
 *	cancelled).
 *
 *	Notes: All commands issued by upper levels already have a timeout
 *	associated with them. A LLD can use this function to cancel the
 *	timer.
 *
 *	Defined in: drivers/scsi/scsi_error.c
 **/
int scsi_delete_timer(Scsi_Cmnd *scmd)


/**
 * scsi_partsize - parse partition table into cylinders, heads + sectors
 * @buf: pointer to partition table
 * @capacity: size of (total) disk in 512 byte sectors
 * @cyls: outputs number of cylinders calculated via this pointer
 * @hds: outputs number of heads calculated via this pointer
 * @secs: outputs number of sectors calculated via this pointer
 *
 *	Returns 0 on success, -1 on failure
 *
 *	Notes: Caller owns memory returned (free with kfree() )
 *
 *	Defined in: drivers/scsi/scsicam.c
 **/
int scsi_partsize(unsigned char *buf, unsigned long capacity,
                  unsigned int *cyls, unsigned int *hds, unsigned int *secs)


/**
 * scsi_register - create and register a scsi host adapter instance.
 * @shost_tp:   pointer to scsi host template
 * @xtr_bytes:  extra bytes to allocate in hostdata array (which is the
 *		last member of the returned Scsi_Host instance)
 *
 *      Returns pointer to new Scsi_Host instance or NULL on failure
 *
 *	Notes: When this call returns to the LLDD, the SCSI bus scan on
 *	this host has _not_ yet been done.
 *	The hostdata array (by default zero length) is a per host scratch 
 *	area for the LLD.
 *
 *	Defined in: drivers/scsi/hosts.c .
 **/
struct Scsi_Host * scsi_register(struct SHT *, int xtr_bytes)


/**
 * scsi_register_host - register a low level host driver
 * @shost_tp:   pointer to a scsi host driver template
 *
 *      Returns 0 on Success, 1 on failure
 *
 *      Notes: Should only be invoked if the "passive initialization
 *	model" is being used. Notice this is a _driver_ rather than 
 *	HBA registration function. Most older drivers call this
 *	function by including the scsi_module.c file.
 *	This function is deprecated, use the "hotplug initialization
 *	model" instead.
 *
 *	Defined in: drivers/scsi/hosts.c .
 **/
int scsi_register_host(Scsi_Host_Template *shost_tp)


/**
 * scsi_remove_device - detach and remove a SCSI device
 * @sdev:      a pointer to a scsi device instance
 *
 *	Returns value: 0 on success, -EINVAL if device not attached
 *
 *      Notes: If a LLD becomes aware that a scsi device (lu) has
 *	been removed but its host is still present then it can request
 *	the removal of that scsi device. If successful this call will
 *	lead to the slave_destroy() callback being invoked. sdev is an 
 *	invalid pointer after this call.
 *
 *	Defined in: drivers/scsi/scsi_scan.c .
 **/
int scsi_remove_device(struct scsi_device *sdev)


/**
 * scsi_remove_host - detach and remove all SCSI devices owned by host
 * @shost:      a pointer to a scsi host instance
 *
 *	Returns value: 0 on success, 1 on failure (e.g. LLD busy ??)
 *
 *      Notes: Should only be invoked if the "hotplug initialization
 *	model" is being used. It should be called _prior_ to  
 *	scsi_unregister().
 *
 *	Defined in: drivers/scsi/hosts.c .
 **/
int scsi_remove_host(struct Scsi_Host *shost)


/**
 * scsi_report_bus_reset - report scsi _bus_ reset observed
 * @shost: a pointer to a scsi host involved
 * @channel: channel (within) host on which scsi bus reset occurred
 *
 *	Returns nothing
 *
 *      Notes: This only needs to be called if the reset is one which
 *	originates from an unknown location.  Resets originated by the 
 *	mid level itself don't need to call this, but there should be 
 *	no harm.  The main purpose of this is to make sure that a
 *	CHECK_CONDITION is properly treated.
 *
 *	Defined in: drivers/scsi/scsi_lib.c .
 **/
void scsi_report_bus_reset(struct Scsi_Host * shost, int channel)


/**
 * scsi_set_device - place device reference in host structure
 * @shost: a pointer to a scsi host instance
 * @pdev: pointer to device instance to assign
 *
 *	Returns nothing
 *
 *      Defined in: drivers/scsi/hosts.h .
 **/
void scsi_set_device(struct Scsi_Host * shost, struct device * dev)


/**
 * scsi_set_device_offline - set device offline then flush its queue
 * @sdev: a pointer to a scsi device instance to be set offline
 *
 *	Returns nothing
 *
 *      Notes: Commands that are currently active on the scsi device have 
 *	       their timers cancelled and are transferred to the host's
 *	       "eh" list for cancellation. 

 *	Defined in: drivers/scsi/scsi.c .
 **/
void scsi_set_device_offline(struct scsi_device * sdev)


/**
 * scsi_to_pci_dma_dir - convert SCSI subsystem direction flag to PCI
 * @scsi_data_direction: SCSI subsystem direction flag
 *
 *	Returns PCI_DMA_TODEVICE given SCSI_DATA_WRITE,
 *		PCI_DMA_FROMDEVICE given SCSI_DATA_READ
 *		PCI_DMA_BIDIRECTIONAL given SCSI_DATA_UNKNOWN
 *		else returns PCI_DMA_NONE
 *
 *      Defined in: drivers/scsi/scsi.h .
 **/
int scsi_to_pci_dma_dir(unsigned char scsi_data_direction)


/**
 * scsi_to_sbus_dma_dir - convert SCSI subsystem direction flag to SBUS
 * @scsi_data_direction: SCSI subsystem direction flag
 *
 *	Returns SBUS_DMA_TODEVICE given SCSI_DATA_WRITE,
 *		SBUS_DMA_FROMDEVICE given SCSI_DATA_READ
 *		SBUS_DMA_BIDIRECTIONAL given SCSI_DATA_UNKNOWN
 *		else returns SBUS_DMA_NONE
 *
 *      Defined in: drivers/scsi/scsi.h .
 **/
int scsi_to_sbus_dma_dir(unsigned char scsi_data_direction)


/**
 * scsi_track_queue_full - track successive QUEUE_FULL events on given
 *			device to determine if and when there is a need
 *			to adjust the queue depth on the device.
 * @SDptr: pointer to SCSI device instance
 * @depth: Current number of outstanding SCSI commands on this device,
 *	   not counting the one returned as QUEUE_FULL.
 *
 *      Returns 0  - no change needed
 *		>0 - adjust queue depth to this new depth
 *		-1 - drop back to untagged operation using host->cmd_per_lun
 *		     as the untagged command depth
 *
 *      Notes: LLDs may call this at any time and we will do "The Right
 *		Thing"; interrupt context safe. 
 *
 *	Defined in: drivers/scsi/scsi.c .
 **/
int scsi_track_queue_full(Scsi_Device *SDptr, int depth)


/**
 * scsi_unblock_requests - allow further commands to be queued to given host
 *
 * @SHpnt: pointer to host to unblock commands on
 *
 *	Returns nothing
 *
 * 	Defined in: drivers/scsi/scsi_lib.c .
**/
void scsi_unblock_requests(struct Scsi_Host * SHpnt)


/**
 * scsi_unregister - unregister and free memory used by host instance
 * @shp:	pointer to scsi host instance to unregister.
 *
 *	Returns nothing
 *
 *      Notes: Should only be invoked if the "hotplug initialization
 *	model" is being used. It should be called _after_  
 *	scsi_remove_host(). The shp pointer is invalid after this call.
 *
 *	Defined in: drivers/scsi/hosts.c .
 **/
void scsi_unregister(struct Scsi_Host * shp)


/**
 * scsi_unregister_host - unregister a low level host adapter driver
 * @shost_tp:   scsi host template to unregister.
 *
 *	Returns 0 on Success, 1 on Failure
 *
 *      Notes: Should only be invoked if the "passive initialization
 *	model" is being used. Notice this is a _driver_ rather than 
 *	HBA deregistration function. So if there are multiple HBAs
 *	associated with the given template, they are each removed. Most 
 *	older drivers call this function by including the scsi_module.c
 *	file. This function is deprecated, use the "hotplug initialization
 *	model" instead.
 *
 *	Defined in: drivers/scsi/hosts.c .
 **/
int scsi_unregister_host(Scsi_Host_Template *shost_tp)



Interface Functions
===================
Interface functions are supplied (defined) by LLDs and
their function pointers are placed in an instance of struct SHT which
is passed to scsi_register() [or scsi_register_host()]. Some
are mandatory. Interface functions should be declared static. The 
accepted convention is that driver "xyz" will declare its slave_configure() 
function as:
    static int xyz_slave_configure(struct scsi_device * sdev);

A pointer to this function should be placed in the 'slave_configure' member
of a "struct SHT" instance. A pointer to such an instance should
passed to the mid level's scsi_register() [or scsi_register_host()].

The interface functions are also described in the hosts.h file immediately
above their definition point in "struct SHT". In some cases more detail
is given in hosts.h than below.

Those interface functions marked "Required: yes" must be implemented
by the LLD and a pointer to that function must be placed in the driver's
"struct SHT" instance. Interface functions marked "Required: no" need not
be implemented.

The interface functions are listed below in alphabetical order.

Summary:
   bios_param - fetch head, sector, cylinder info for a disk
   command - send scsi command to device, wait for reply
   detect - detects HBAs this driver wants to control
   eh_abort_handler - abort given command
   eh_bus_reset_handler - issue SCSI bus reset
   eh_device_reset_handler - issue SCSI device reset
   eh_host_reset_handler - reset host (host bus adapter)
   eh_strategy_handler - driver supplied alternate to scsi_unjam_host()
   info - supply information about given host
   ioctl - driver can respond to ioctls
   proc_info - supports /proc/scsi/{driver_name}/{host_no}
   queuecommand - queue scsi command, invoke 'done' on completion
   release - release all resources associated with given host
   slave_alloc - prior to any commands being sent to a new device 
   slave_configure - driver fine tuning for given device after attach
   slave_destroy - given device is about to be shut down

Details:

/**
 *      bios_param - fetch head, sector, cylinder info for a disk
 *      @sdev: pointer to scsi device context (defined in scsi.h)
 *      @bdev: pointer to block device context (defined in fs.h)
 *	@capacity:  device size (in 512 byte sectors)
 *      @params: three element array to place output:
 *              params[0] number of heads (max 255)
 *              params[1] number of sectors (max 63)
 *              params[2] number of cylinders 
 *
 *      Return value is ignored
 *
 *      Required: no
 *
 *      Locks: none
 *
 *      Notes: an arbitrary geometry (based on READ CAPACITY) is used
 *      if this function is not provided. The params array is
 *      pre-initialized with made up values just in case this function 
 *      doesn't output anything.
 *
 *	Defined in: LLD
 **/
    int bios_param(struct scsi_device * sdev, struct block_device *bdev,
    		   sector_t capacity, int params[3]);


/**
 *      command - send scsi command to device, wait for reply
 *      @scp: pointer to scsi command object
 *
 *      Returns an int with four component bytes: scsi_byte, msg_byte, 
 *      host_byte, driver_byte (status_byte is in the lsb). A value of
 *      0 is an unqualified success.
 *
 *      Required: if struct Scsi_Host::can_queue can ever by cleared (zero)
 *                then this function is required.
 *
 *      Locks: struct Scsi_Host::host_lock held on entry (with "irqsave")
 *             and is expected to be held on return.
 *
 *      Notes: Drivers tend to be dropping support for this function and
 *      supporting queuecommand() instead.
 *
 *	Defined in: LLD
 **/
    int command(struct scsi_cmnd * scp);


/**
 *      detect - detects HBAs this driver wants to control
 *      @shtp: host template for this driver.
 *
 *      Returns number of hosts this driver wants to control. 0 means no
 *      suitable hosts found.
 *
 *      Required: yes, if "passive initialization mode" is used
 *		  [in "hotplug initialization mode" it is not invoked]
 *
 *      Locks: none held
 *
 *      Notes: First function called from the SCSI mid level on this
 *      driver. Upper level drivers (e.g. sd) may not (yet) be present.
 *      For each host found, this method should call scsi_register() 
 *      [see hosts.c].
 *
 *	Defined in: LLD
 **/
    int detect(struct SHT * shtp);


/**
 *      eh_abort_handler - abort command associated with scp
 *      @scp: identifies command to be aborted
 *
 *      Returns SUCCESS if command aborted else FAILED
 *
 *      Required: no
 *
 *      Locks: struct Scsi_Host::host_lock held (with irqsave) on entry 
 *	and assumed to be held on return.
 *
 *      Notes: Invoked from scsi_eh thread. No other commands will be
 *      queued on current host during eh.
 *
 *	Defined in: LLD
 **/
     int eh_abort_handler(struct scsi_cmnd * scp);


/**
 *      eh_bus_reset_handler - issue SCSI bus reset
 *      @scp: SCSI bus that contains this device should be reset
 *
 *      Returns SUCCESS if command aborted else FAILED
 *
 *      Required: no
 *
 *      Locks: struct Scsi_Host::host_lock held (with irqsave) on entry 
 *	and assumed to be held on return.
 *
 *      Notes: Invoked from scsi_eh thread. No other commands will be
 *      queued on current host during eh.
 *
 *	Defined in: LLD
 **/
     int eh_bus_reset_handler(struct scsi_cmnd * scp);


/**
 *      eh_device_reset_handler - issue SCSI device reset
 *      @scp: identifies SCSI device to be reset
 *
 *      Returns SUCCESS if command aborted else FAILED
 *
 *      Required: no
 *
 *      Locks: struct Scsi_Host::host_lock held (with irqsave) on entry
 *	and assumed to be held on return.
 *
 *      Notes: Invoked from scsi_eh thread. No other commands will be
 *      queued on current host during eh.
 *
 *	Defined in: LLD
 **/
     int eh_device_reset_handler(struct scsi_cmnd * scp);


/**
 *      eh_host_reset_handler - reset host (host bus adapter)
 *      @scp: SCSI host that contains this device should be reset
 *
 *      Returns SUCCESS if command aborted else FAILED
 *
 *      Required: no
 *
 *      Locks: struct Scsi_Host::host_lock held (with irqsave) on entry
 *	and assumed to be held on return.
 *
 *      Notes: Invoked from scsi_eh thread. No other commands will be
 *      queued on current host during eh. 
 *      With the default eh_strategy in place, if none of the _abort_, 
 *      _device_reset_, _bus_reset_ or this eh handler function are 
 *      defined (or they all return FAILED) then the device in question 
 *      will be set offline whenever eh is invoked.
 *
 *	Defined in: LLD
 **/
     int eh_host_reset_handler(struct scsi_cmnd * scp);


/**
 *      eh_strategy_handler - driver supplied alternate to scsi_unjam_host()
 *      @shp: host on which error has occurred
 *
 *      Returns TRUE if host unjammed, else FALSE.
 *
 *      Required: no
 *
 *      Locks: none
 *
 *      Notes: Invoked from scsi_eh thread. Driver supplied alternate to 
 *      scsi_unjam_host() found in scsi_error.c
 *
 *	Defined in: LLD
 **/
     int eh_strategy_handler(struct Scsi_Host * shp);


/**
 *      info - supply information about given host: driver name plus data
 *             to distinguish given host
 *      @shp: host to supply information about
 *
 *      Return ASCII null terminated string. [This driver is assumed to
 *      manage the memory pointed to and maintain it, typically for the
 *      lifetime of this host.]
 *
 *      Required: no
 *
 *      Locks: none
 *
 *      Notes: Often supplies PCI or ISA information such as IO addresses
 *      and interrupt numbers. If not supplied struct Scsi_Host::name used
 *      instead. It is assumed the returned information fits on one line 
 *      (i.e. does not included embedded newlines).
 *      The SCSI_IOCTL_PROBE_HOST ioctl yields the string returned by this
 *      function (or struct Scsi_Host::name if this function is not
 *	available).
 *      In a similar manner, scsi_register_host() outputs to the console
 *      each host's "info" (or name) for the driver it is registering.
 *      Also if proc_info() is not supplied, the output of this function
 *      is used instead.
 *
 *	Defined in: LLD
 **/
    const char * info(struct Scsi_Host * shp);


/**
 *      ioctl - driver can respond to ioctls
 *      @sdp: device that ioctl was issued for
 *      @cmd: ioctl number
 *      @arg: pointer to read or write data from. Since it points to
 *            user space, should use appropriate kernel functions
 *            (e.g. copy_from_user() ). In the Unix style this argument
 *            can also be viewed as an unsigned long.
 *
 *      Returns negative "errno" value when there is a problem. 0 or a
 *      positive value indicates success and is returned to the user space.
 *
 *      Required: no
 *
 *      Locks: none
 *
 *      Notes: The SCSI subsystem uses a "trickle down" ioctl model.
 *      The user issues an ioctl() against an upper level driver
 *      (e.g. /dev/sdc) and if the upper level driver doesn't recognize
 *      the 'cmd' then it is passed to the SCSI mid level. If the SCSI
 *      mid level does not recognize it, then the LLD that controls
 *      the device receives the ioctl. According to recent Unix standards
 *      unsupported ioctl() 'cmd' numbers should return -ENOTTY.
 *      However the mid level returns -EINVAL for unrecognized 'cmd'
 *      numbers when this function is not supplied by the driver.
 *      Unfortunately some applications expect -EINVAL and react badly
 *	when -ENOTTY is returned; stick with -EINVAL.
 *
 *	Defined in: LLD
 **/
    int ioctl(struct scsi_device *sdp, int cmd, void *arg);


/**
 *      proc_info - supports /proc/scsi/{driver_name}/{host_no}
 *      @buffer: anchor point to output to (0==writeto1_read0) or fetch from
 *               (1==writeto1_read0).
 *      @start: where "interesting" data is written to. Ignored when
 *              1==writeto1_read0.
 *      @offset: offset within buffer 0==writeto1_read0 is actually
 *               interested in. Ignored when 1==writeto1_read0 .
 *      @length: maximum (or actual) extent of buffer
 *      @host_no: host number of interest (struct Scsi_Host::host_no)
 *      @writeto1_read0: 1 -> data coming from user space towards driver
 *                            (e.g. "echo some_string > /proc/scsi/xyz/2")
 *                       0 -> user what data from this driver
 *                            (e.g. "cat /proc/scsi/xyz/2")
 *
 *      Returns length when 1==writeto1_read0. Otherwise number of chars
 *      output to buffer past offset.
 *
 *      Required: no
 *
 *      Locks: none held
 *
 *      Notes: Driven from scsi_proc.c which interfaces to proc_fs
 *
 *	Defined in: LLD
 **/
int proc_info(char * buffer, char ** start, off_t offset, 
              int length, int hostno, int writeto1_read0);


/**
 *      queuecommand - queue scsi command, invoke 'done' on completion
 *      @scp: pointer to scsi command object
 *      @done: function pointer to be invoked on completion
 *
 *      Returns 1 if the adapter (host) is busy, else returns 0. One
 *		reason for an adapter to be busy is that the number
 *		of outstanding queued commands is already equal to
 *		struct Scsi_Host::can_queue .
 *
 *      Required: if struct Scsi_Host::can_queue is ever non-zero
 *                then this function is required.
 *
 *      Locks: struct Scsi_Host::host_lock held on entry (with "irqsave")
 *             and is expected to be held on return.
 *
 *      Notes: This function should be relatively fast. Normally it will
 *      not wait for IO to complete. Hence the 'done' callback is invoked 
 *      (often directly from an interrupt service routine) sometime after
 *      this command has returned. In some cases (e.g. pseudo adapter 
 *      drivers that manufacture the response to a SCSI INQUIRY)
 *      the 'done' callback may be invoked before this function returns.
 *      If the 'done' callback is not invoked within a certain period
 *      the SCSI mid level will commence error processing.
 *      The integer with 4 component bytes that command() uses as its
 *      return value should be generated by this function. However, in
 *      this case, it should be placed in scp->result before this function 
 *      returns.
 *      If a status of CHECK CONDITION is placed in "result" when the
 *	'done' callback is invoked, then the LLD driver should 
 *	perform autosense and fill in the struct scsi_cmnd::sense_buffer
 *	array.
 *
 *	Defined in: LLD
 **/
    int queuecommand(struct scsi_cmnd * scp, 
		     void (*done)(struct scsi_cmnd *));


/**
 *      release - release all resources associated with given host
 *      @shp: host to be released.
 *
 *      Return value ignored (could soon be a function returning void).
 *
 *      Required: yes (see notes)
 *
 *      Locks: none held
 *
 *      Notes: Invoked from mid level's scsi_unregister_host().
 *      LLD's implementation of this function should call 
 *	scsi_unregister(shp) prior to returning.
 *	If not supplied mid-level [in hosts.c] supplies its own
 *	implementation (see scsi_host_legacy_release()) which is for old
 *	ISA adapters so it is best not to use it.
 *
 *	Defined in: LLD
 **/
    int release(struct Scsi_Host * shp);


/**
 *      slave_alloc -	prior to any commands being sent to a new device 
 *			(i.e. just prior to scan) this call is made
 *      @sdp: pointer to new device (about to be scanned)
 *
 *      Returns 0 if ok. Any other return is assumed to be an error and
 *	the device is ignored.
 *
 *      Required: no
 *
 *      Locks: none
 *
 *      Notes: Allows the driver to allocate any resources for a device
 *	prior to its initial scan. The corresponding scsi device may not
 *	exist but the mid level is just about to scan for it (i.e. send
 *	and INQUIRY command plus ...). If a device is found then
 *	slave_configure() will be called while if a device is not found
 *	slave_destroy() is called.
 *      For more details see the hosts.h file.
 *
 *	Defined in: LLD
 **/
    int slave_alloc(struct scsi_device *sdp);


/**
 *      slave_configure - driver fine tuning for given device just after it
 *		       has been first scanned (i.e. it responded to an
 *		       INQUIRY)
 *      @sdp: device that has just been attached
 *
 *      Returns 0 if ok. Any other return is assumed to be an error and
 *	the device is taken offline. [offline devices will _not_ have
 *	slave_destroy() called on them so clean up resources.]
 *
 *      Required: no
 *
 *      Locks: none
 *
 *      Notes: Allows the driver to inspect the response to the initial
 *	INQUIRY done by the scanning code and take appropriate action.
 *	For more details see the hosts.h file.
 *
 *	Defined in: LLD
 **/
    int slave_configure(struct scsi_device *sdp);


/**
 *      slave_destroy - given device is about to be shut down. All
 *			activity has ceased on this device.
 *      @sdp: device that is about to be shut down
 *
 *      Returns nothing
 *
 *      Required: no
 *
 *      Locks: none
 *
 *      Notes: Mid level structures for given device are still in place
 *	but are about to be torn down. Any per device resources allocated
 *	by this driver for given device should be freed now. No further
 *	commands will be sent for this sdp instance. [However the device
 *	could be re-attached in the future in which case a new instance
 *	of struct scsi_device would be supplied by future slave_alloc()
 *	and slave_configure() calls.]
 *
 *	Defined in: LLD
 **/
    void slave_destroy(struct scsi_device *sdp);



Data Structures
===============
struct SHT
----------
There is one "struct SHT" instance per LLD ***. It is
typically initialized as a file scope static in a driver's header file. That
way members that are not explicitly initialized will be set to 0 or NULL.
Member of interest:
    name         - name of driver (may contain spaces, please limit to
                   less than 80 characters)
    proc_name    - name used in "/proc/scsi/<proc_name>/<host_no>" and
                   by sysfs in one of its "drivers" directories. Hence
                   "proc_name" should only contain characters acceptable
                   to a Unix file name.
   (*release)()  - should be defined by all LLDs as the default (legacy)
                   implementation is only appropriate for ISA adapters).
The structure is defined and commented in hosts.h

*** In extreme situations a single driver may have several instances
    if it controls several different classes of hardware (e.g. the
    advansys driver handles both ISA and PCI cards and has a separate
    instance of struct SHT for each).

struct Scsi_Host
----------------
There is one struct Scsi_Host instance per host (HBA) that a LLD
controls. The struct Scsi_Host structure has many members in common
with "struct SHT". When a new struct Scsi_Host instance is created (in
scsi_register() in hosts.c) those common members are initialized from
the driver's struct SHT instance. Members of interest:
    host_no      - system wide unique number that is used for identifying
                   this host. Issued in ascending order from 0 (and the
                   positioning can be influenced by the scsihosts
                   kernel boot (or module) parameter)
    can_queue    - 0->use command(), greater than 0->use queuecommand() and
                   do not send more than can_queue commands to the adapter.
    this_id      - scsi id of host (scsi initiator) or -1 if not known
    sg_tablesize - maximum scatter gather elements allowed by host.
                   0 implies scatter gather not supported by host
    max_sectors  - maximum number of sectors (usually 512 bytes) allowed
                   in a single SCSI command. 0 implies no maximum.
    cmd_per_lun  - maximum number of command that can be queued on devices
                   controlled by the host. Overridden by LLD calls to
		   scsi_adjust_queue_depth().
    unchecked_isa_dma - 1->only use bottom 16 MB of ram (ISA DMA addressing
                   restriction), 0->can use full 32 bit (or better) DMA
                   address space
    use_clustering - 1->SCSI commands in mid level's queue can be merged,
                     0->disallow SCSI command merging
    highmem_io   - 1->can DMA in to or out of high memory,
                   0->use bounce buffers if data is in high memory
    hostt        - pointer to driver's struct SHT from which this
                   struct Scsi_Host instance was spawned
    sh_list      - a double linked list of pointers to all struct Scsi_Host
                   instances (currently ordered by ascending host_no)
    my_devices   - a double linked list of pointers to struct scsi_device 
		   instances that belong to this host.
    hostdata[0]  - area reserved for LLD at end of struct Scsi_Host. Size
                   is set by the second argument (named 'xtr_bytes') to
                   scsi_register().
The structure is defined in hosts.h

struct scsi_device
------------------
Generally, there is one instance of this structure for each SCSI logical unit
on a host. Scsi devices are uniquely identified within a host by bus number,
cahnnel number, target id and logical unit number (lun).
The structure is defined in scsi.h

struct scsi_cmnd
----------------
Instances of this structure convey SCSI commands to the LLD and responses
back to the mid level. The SCSI mid level will ensure that no more SCSI 
commands become queued against the LLD than are indicated by 
scsi_adjust_queue_depth() (or struct Scsi_Host::cmd_per_lun). There will 
be at least one instance of struct scsi_cmnd available for each SCSI device. 
The structure is defined in scsi.h


Locks
=====
Each struct Scsi_Host instance has a spin_lock called struct 
Scsi_Host::default_lock which is initialized in scsi_register() [found in 
hosts.c]. Within the same function the struct Scsi_Host::host_lock pointer
is initialized to point at default_lock with the scsi_assign_lock() function.
Thereafter lock and unlock operations performed by the mid level use the
struct Scsi_Host::host_lock pointer.

LLDs can override the use of struct Scsi_Host::default_lock by
using scsi_assign_lock(). The earliest opportunity to do this would
be in the detect() function after it has invoked scsi_register(). It
could be replaced by a coarser grain lock (e.g. per driver) or a
lock of equal granularity (i.e. per host). Using finer grain locks 
(e.g. per SCSI device) may be possible by juggling locks in
queuecommand().

Autosense
=========
Autosense (or auto-sense) is defined in the SAM-2 document as "the
automatic return of sense data to the application client coincident
with the completion of a SCSI command" when a status of CHECK CONDITION
occurs. LLDs should perform autosense. This should be done when the LLD
detects a CHECK CONDITION status by either: 
    a) instructing the SCSI protocol (e.g. SCSI Parallel Interface (SPI))
       to perform an extra data in phase on such responses
    b) or, the LLD issuing a REQUEST SENSE command itself

Either way, the mid level decides whether the LLD has 
performed autosense by checking struct scsi_cmnd::sense_buffer[0] . If this
byte has an upper nibble of 7 (or 0xf) then autosense is assumed to have 
taken place. If it has another value (and this byte is initialized to 0
before each command) then the mid level will issue a REQUEST SENSE command.

In the presence of queued commands the "nexus" that maintains sense
buffer data from the command that failed until a following REQUEST SENSE
may get out of synchronization. This is why it is best for the LLD
to perform autosense.


Changes since lk 2.4 series
===========================
io_request_lock has been replaced by several finer grained locks. The lock 
relevant to LLDs is struct Scsi_Host::host_lock and there is
one per SCSI host.

The older error handling mechanism has been removed. This means the
LLD interface functions abort() and reset() have been removed.
The struct SHT::use_new_eh_code flag has been removed.

In the 2.4 series the SCSI subsystem configuration descriptions were 
aggregated with the configuration descriptions from all other Linux 
subsystems in the Documentation/Configure.help file. In the 2.5 series, 
the SCSI subsystem now has its own (much smaller) drivers/scsi/Config.help
file.

Addition of slave_alloc(), slave_configure() and slave_destroy().

Addition of the "hotplug initialization model".


Credits
=======
The following people have contributed to this document:
        Mike Anderson <andmike@us.ibm.com>
        James Bottomley <James.Bottomley@steeleye.com> 
        Patrick Mansfield <patmans@us.ibm.com> 
	Christoph Hellwig <hch@infradead.org>
	Doug Ledford <dledford@redhat.com>
        Andries Brouwer <Andries.Brouwer@cwi.nl>


Douglas Gilbert
dgilbert@interlog.com
29th April 2003
